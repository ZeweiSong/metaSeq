#!/usr/bin/env perl
# (c) 2016 - 2019 Chao IN-HORSE SHARE ONLY
# ===================================================================
# Description:       functions to read files
# Author:            Chao | fangchao@genomics.cn
# Version:           v0.1
# Last modified:     03 Jan 2019 (since 03 Jan 2019)
# ===================================================================
# see detail below
use strict;
use Getopt::Long qw(:config no_ignore_case);
our($verbose,$help);
sub usage {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  IO <mode> [option]
  func:
    UCH    get seq from H records of a UC file
    maketree find cluster anno info and make a tree

options:  Defined according to the mode and cmd you chosed.
USAGE
}

&usage("Stating beads related information") && exit if @ARGV == 0 || $ARGV[0] eq "-h";

my $mode = shift @ARGV unless $ARGV[0] =~/^-/;

# Main start
&run_getUCH if $mode eq "uch";
&run_validseq if $mode eq "validseq";
&run_validseqTwo if $mode eq "validseq2";
&run_maketree if $mode eq "maketree";
&run_maketaxon if $mode eq "maketaxon";
&run_kk2prf if $mode eq "kk2prf";# Main end
&run_sumprf if $mode eq "sumprf";
&run_sumgff if $mode eq "sumgff";
&run_itsx if $mode eq "itsx";
&run_uc2fa if $mode eq "uc2fa";
&run_treeAnno if $mode eq "treeanno";
&run_printUniqSubunit if $mode eq "printUniqSubunit";
&run_printITSxSubunit if $mode eq "printITSxSubunit";
&run_makeClade if $mode eq "makeclade";
&run_clade2tree if $mode eq "clade2tree";
&run_tree2fa if $mode eq "tree2fa";
&run_observedOTUs if $mode eq "observedOTUs";
&run_modKKreport if $mode eq "modKKreport";
&run_test if $mode eq "test";
&verbose("[All done!]\n");

exit;

sub verbose{
  my $msg = shift;
  print STDERR $msg if $verbose;
}

##############################################################################
### UCH:  Get seq from H records of a UC file
##############################################################################
sub usage4uch {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 uch -i fasta -u clust.uc -o output.fa
    -a  bead annotation file (to remove potential hybridize bead)
    -i  fasta file
    -u  cluster file with 10 column
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_getUCH {
  &usage4uch("Output sequence ID that can be clustered.") && exit unless @ARGV;
  my ($cut,$ann,$inf,$ucf,$out);
  GetOptions(
    "c=f" => \$cut,
    "a=s" => \$ann,
    "i=s" => \$inf,
    "u=s" => \$ucf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4uch("Output sequence ID that can be clustered.") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  open ANN, "< $ann" or die $!;
  open UCF, "< $ucf" or die $!;
  open INF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
 my (%HYB,%ABG);
  while(<ANN>){
    chomp;
    my @s = split "\t";
    my @b = split(/\|/, $s[0]);
    if(@s == 27){
      $HYB{$b[0]} = 0;
      if($s[-7] eq "multi" && $s[-6] ne "sameSp."){
        $ABG{$b[0]} ++;
      }
    }elsif(@s == 30){
      if($s[-3] > 0){
        $HYB{$b[0]} ++;
      }
      if($s[19] eq "multi" && $s[20] ne "sameSp."){
        $ABG{$b[0]} ++;
      }
    }

  }
  close ANN;

  &verbose("[log] Mode [UCH] start ... \n");
  my(%CLUST,%TMP,%LOG);
  #Here is the shorts for each column. Find more detail in VSEARCH manual.
  ##   0         1       2            3            4  5  6      7     8        9##
  ##Type  #Cluster  length  similarity%  orientation  *  *  CIGAR query centroid##
  while(<UCF>){
    chomp;
    #next unless /^H/;
    my @s = split "\t";
    if($s[0] eq "S"){
      $TMP{$s[8]}{L} = $s[2];
    }elsif($s[0] eq "H"){
      my @b8 = split "_",$s[8];
      if($s[2] < $cut){
        $LOG{LEN} ++;
      }elsif(defined $HYB{$b8[0]}){
        $LOG{HYB} ++;
      }elsif(defined $ABG{$b8[0]}){
        $LOG{ABG} ++;
      }else{
        $LOG{USE} ++;
        $CLUST{$s[8]} ++;
      }
      next unless exists $TMP{$s[9]};
      if($TMP{$s[9]}{L} < $cut){
        $LOG{LEN} ++;
      }elsif(defined $HYB{$b8[0]}){
        $LOG{HYB} ++;
      }elsif(defined $ABG{$b8[0]}){
        $LOG{ABG} ++;
      }else{
        $LOG{USE} ++;
        $CLUST{$s[9]} ++;
      }
      delete $TMP{$s[9]};
    }

  }
  close UCF;
  $/=">";
  while(<INF>){
    chomp;
    my @s = split "\n";
    (my $id = $s[0]) =~/(\s|\t).*$/;
    if(exists $CLUST{$id}){
      print OUT ">".join("\n",@s)."\n";
    }
  }
  close INF;
  close OUT;

  &verbose("[log] Finish read&write.\n");
  &verbose("[log] Totally write $LOG{USE} sequences.\n");
  &verbose("[log] Discard $LOG{LEN} due to length < $cut\n") if $LOG{LEN} > 0;
  &verbose("[log] Discard $LOG{HYB} due to hybridization detected\n") if $LOG{HYB} > 0;
  &verbose("[log] Discard $LOG{ABG} due to ambiguous classific annotation detected\n") if $LOG{ABG} > 0;
}

##############################################################################
### validseq:  Get domain detected and non-hybridized seqs
##############################################################################
sub usage4validseq {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 validseq -i fasta -g gff [-t txt] [-a anno] [-d domain] -o output.fa
    -a  bead annotation file (to remove potential hybridize bead)
    -i  fasta file
    -g  barrnap gff
    -t  ITSx prediction.txt
    -d  specific domain required. the str can be one of following:
          [ALL]  include SSU,ITS1,5.8S,ITS2,LSU for eukaryote or SSU,LSU for bacterial
          [SSU]  SSU should be detected, including 16S/18S
          [LSU]  LSU should be detected, including 18S/28S
          [ITS]  ITS should be detected, including ITS1/ITS2
          [5.8S] 5.8S should be detected.
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_validseq {
  &usage4uch("Output sequence ID that can be clustered.") && exit unless @ARGV;
  my ($gff,$txt,$ann,$inf,$dom,$min,$max,$out);
  GetOptions(
    "g=s" => \$gff,
    "a=s" => \$ann,
    "i=s" => \$inf,
    "t=s" => \$txt,
    "d=s" => \$dom,
    "m=i" => \$min,
    "M=i" => \$max,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4validseq("Get domain detected and non-hybridized seqs") && exit if $help;

  &verbose("[log] Mode [validseq] start ... \n");
  my(%DOMAIN,%ANNOPICK,%ANNODIRTY,%HMMPICK, %CLUST,%TMP,%LOG);
  $min||=0;
  $max||=0;
  #&usage("[fatal] Essential input is missing");
  open INF, "< $inf" or die $!;
  open GFF, "< $gff" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  #
  if($ann){
    &verbose("[log] Read annotation ... ");
    open ANN, "< $ann" or die $!;
    while(<ANN>){
      chomp;
      my @s = split "\t";
      my @b = split(/\|/, $s[0]);
      my($hyb,$abg,$len,$map)=(0,0,0,0);
      if(@s == 27){
        if($s[-7] eq "multi" && $s[-6] eq "diffGe."){
          $abg = 1;
        }
      }elsif(@s == 30){
        if($s[-3] > 0 & $s[-2] > 499){
          $hyb = 1;
        }
        if($s[19] eq "multi" && $s[20] eq "diffGe."){
          $abg = 1;
        }
      }elsif(@s == 34){
        if($s[-3] > 0 & $s[-2] > 499){
          $hyb = 1;
        }
        if($s[20] eq "multi" && $s[22] eq "diffGe."){
          $abg = 1;
        }
      }
      if($abg+$hyb==0){
        $ANNOPICK{$b[0]} ++;
      }else{
        $ANNODIRTY{$b[0]} ++;
      }
    }
    close ANN;
    &verbose("done\n");
  }
  #
  &verbose("[log] Read barrnap gff ... ");
  while(<GFF>){
    my $id = &getBID($_);
    $HMMPICK{$id} ++;
    $_ =~ /Name=(\S+)_rRNA/;
    my $domain = $1;
    $DOMAIN{$id}{$domain} ++;
    $DOMAIN{$id}{"SSU"} ++ if $domain =~ /16S|18S/;
    $DOMAIN{$id}{"LSU"} ++ if $domain =~ /18S|25S|28S/;
  }
  close GFF;
  &verbose("done\n");
  #
  if($txt){
    &verbose("[log] Read ITS.positions.txt ... ");
    open TXT, "<$txt" or die $!;
    while(<TXT>){
      my $id = &getBID($_);
      $HMMPICK{$id} ++;
      $DOMAIN{$id}{"SSU"} ++ if $_ =~ /SSU: (\d+)-(\d+)/;
      $DOMAIN{$id}{"LSU"} ++ if $_ =~ /LSU: (\d+)-(\d+)/;
      $DOMAIN{$id}{"ITS1"} ++ if $_ =~ /ITS1: (\d+)-(\d+)/;
      $DOMAIN{$id}{"ITS2"} ++ if $_ =~ /ITS2: (\d+)-(\d+)/;
      $DOMAIN{$id}{"5.8S"} ++ if $_ =~ /5.8S: (\d+)-(\d+)/;
    }
    close TXT;
    &verbose("done\n");
  }
  #
  &verbose("[log] Start filter and write ... ");
  my($dpick,$hpick,$apick,$dirty,$badSize) = (0,0,0,0,0);
  $/=">";
  while(<INF>){
    chomp;
    my @s = split "\n";
    my ($cid,$bid) = &getIDs($s[0]);
    my $len = length($s[1]);
    if($len < $min || ($max > 0 && $max < $len)){
      $badSize ++;
      next;
    }
    if($ANNODIRTY{$bid}>0){
      $dirty ++;
      next;
    }
    if($dom){
      # if set domain then set of ANNOPICK and HMMPICK will be overwritten.
      if($dom eq "ALL"){
        if($DOMAIN{$cid}{"SSU"} && $DOMAIN{$cid}{"ITS1"} && $DOMAIN{$cid}{"5.8S"} &&
        $DOMAIN{$cid}{"ITS2"} && $DOMAIN{$cid}{"LSU"} ){
          $dpick ++;
          print OUT ">".join("\n",@s)."\n";
        }
      }elsif($dom eq "ITS"){
        if($DOMAIN{$cid}{"ITS1"} && $DOMAIN{$cid}{"ITS2"}){
          $dpick ++;
          print OUT ">".join("\n",@s)."\n";
        }
      }elsif($dom eq "SSU"){
        if($DOMAIN{$cid}{SSU} && not $DOMAIN{$cid}{LSU}){
          $dpick ++;
          print OUT ">".join("\n",@s)."\n";
        }
      }elsif($dom eq "LSU"){
        if($DOMAIN{$cid}{LSU} && not $DOMAIN{$cid}{SSU}){
          $dpick ++;
          print OUT ">".join("\n",@s)."\n";
        }
      }else{
        if($DOMAIN{$cid}{$dom}){
          $dpick ++;
          print OUT ">".join("\n",@s)."\n";
        }
      }
    }elsif(exists $HMMPICK{$cid}){
      $hpick ++;
      print OUT ">".join("\n",@s)."\n";
    }elsif(exists $ANNOPICK{$bid}){
      $apick ++;
      print OUT ">".join("\n",@s)."\n";
    }
  }
  close INF;
  close OUT;

  &verbose("done\n");
  if($dom){
    &verbose("[log] Totally write $dpick sequences (dicard due to ambiguous alignment: $dirty | dicard due to length: $badSize).\n");
  }else{
    &verbose("[log] Totally write ".($hpick+$apick)." sequences (hmm: $hpick | ann: $apick | dicard due to ambiguous alignment: $dirty | dicard due to length: $badSize).\n");
  }
}

##############################################################################
### validSeq2:  Get domain detected and non-hybridized seqs
##############################################################################
sub usage4validSeq2 {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 validSeq2 -i fasta [-t barrnap|ITSx] [-a anno] [-d domain] -o output.fa
    -a  bead annotation file (to remove potential hybridize bead)
    -i  barrnap/ITSx file prefix
    -t  type of data, [barrnap|ITSx]
    -d  specific domain required. the str can be one of following:
          [ALL]  include SSU,ITS1,5.8S,ITS2,LSU for eukaryote or SSU,LSU for bacterial
          [SSU]  SSU should be detected, including 16S/18S
          [LSU]  LSU should be detected, including 18S/28S
          [ITS]  ITS should be detected, including ITS1/ITS2
          [5.8S] 5.8S should be detected.
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}

sub run_validseqTwo {
  &usage4validSeq2("Get domain detected and non-hybridized seqs.") && exit unless @ARGV;
  my ($type,$ann,$inf,$dom,$min,$max,$out);
  GetOptions(
    "a=s" => \$ann,
    "i=s" => \$inf,
    "t=s" => \$type,
    "d=s" => \$dom,
    "m=i" => \$min,
    "M=i" => \$max,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4validSeq2("Get domain detected and non-hybridized seqs") && exit if $help;

  &verbose("[log] Mode [validSeq2] start ... \n");
  my(%DOMAIN,%ANNOPICK,%ANNODIRTY,%HMMPICK, %CLUST,%TMP,%LOG);
  $min||=0;
  $max||=0;
  $type||="barnnap";
  #&usage("[fatal] Essential input is missing");
  open OUT, ($out)?">$out":">-" or die $!;
  #
  if($ann){
    &verbose("[log] Read annotation ... ");
    open ANN, "< $ann" or die $!;
    while(<ANN>){
      chomp;
      my @s = split "\t";
      my @b = split(/\|/, $s[0]);
      my($hyb,$abg,$len,$map)=(0,0,0,0);
      if(@s == 27){
        if($s[-7] eq "multi" && $s[-6] eq "diffGe."){
          $abg = 1;
        }
      }elsif(@s == 30){
        if($s[-3] > 0 & $s[-2] > 499){
          $hyb = 1;
        }
        if($s[19] eq "multi" && $s[20] eq "diffGe."){
          $abg = 1;
        }
      }elsif(@s == 34){
        if($s[-3] > 0 & $s[-2] > 499){
          $hyb = 1;
        }
        if($s[20] eq "multi" && $s[22] eq "diffGe."){
          $abg = 1;
        }
      }
      if($abg+$hyb==0){
        $ANNOPICK{$b[0]} ++;
      }else{
        $ANNODIRTY{$b[0]} ++;
      }
    }
    close ANN;
    &verbose("done\n");
  }
  #
  &verbose("[log] Start filter and write ... ");
  my($dpick,$hpick,$apick,$dirty,$badSize,%FNAS) = (0,0,0,0,0,());
  $/=">";
  if($type eq "barrnap"){
    open INF, "< $inf" or die $!;
    while(<INF>){
      chomp;
      my @s = split "\n";
      my $id = shift @s;
      my ($region,$bid,$cid,$start,$stop,$strand,$id) = &readBarrnapID($id);
      if($ANNODIRTY{$bid}>0){
        $dirty ++;
        next;
      }

      if($dom){
        # if set domain then set of ANNOPICK and HMMPICK will be overwritten.
        if($dom =~ /ALL|BOTH|SSU/ && $region eq "16S"){
          $FNAS{$cid}{"id"} ||= $id;
          $FNAS{$cid}{"SSU"} = join("",@s);
          $FNAS{$cid}{"len"} += length($FNAS{$cid}{"SSU"});
        }
        if($dom =~ /ALL|BOTH|LSU/ && $region eq "23S"){
          $FNAS{$cid}{"id"} ||= $id;
          $FNAS{$cid}{"LSU"} = join("",@s);
          $FNAS{$cid}{"len"} += length($FNAS{$cid}{"LSU"});
        }
      }
    }
    close INF;
  }else{
    foreach(split/,/,$inf){
      $_ =~ /(SSU|full|LSU)/;
      my $region = ($1 eq "full")?"ITS":$1;
      open INF, "< $_" or die $!;
      while(<INF>){
        chomp;
        my @s = split "\n";
        my $id = shift @s;
        my ($bid,$cid) = &readITSxID($id);

        if($ANNODIRTY{$bid}>0){
          $dirty ++;
          next;
        }

        if($dom){
          # if set domain then set of ANNOPICK and HMMPICK will be overwritten.
          if($dom =~ /ALL|BOTH|SSU/ && $region eq "SSU"){
            $FNAS{$cid}{"id"} ||= $id;
            $FNAS{$cid}{"SSU"} = join("",@s);
            $FNAS{$cid}{"len"} += length($FNAS{$cid}{"SSU"});

          }
          if($dom =~ /ALL|ITS/ && $region eq "ITS"){
            $FNAS{$cid}{"id"} ||= $id;
            $FNAS{$cid}{"ITS"} = join("",@s);
            $FNAS{$cid}{"len"} += length($FNAS{$cid}{"ITS"});
          }
          if($dom =~ /ALL|BOTH|LSU/ && $region eq "23S"){
            $FNAS{$cid}{"id"} ||= $id;
            $FNAS{$cid}{"LSU"} = join("",@s);
            $FNAS{$cid}{"len"} += length($FNAS{$cid}{"LSU"});
          }
        }
      }
      close INF;
    }
  }

  #print
  foreach my $cid (sort keys %FNAS){
    my $len = $FNAS{$cid}{len};
    if($len < $min || ($max > 0 && $max < $len)){
      $badSize ++;
      next;
    }
    print OUT ">$FNAS{$cid}{id}\n$FNAS{$cid}{SSU}$FNAS{$cid}{ITS}$FNAS{$cid}{LSU}\n";
    $dpick ++;
  }
  close OUT;

  &verbose("done\n");
  if($dom){
    &verbose("[log] Totally write $dpick sequences (dicard due to ambiguous alignment: $dirty | dicard due to length: $badSize).\n");
  }else{
    &verbose("[log] Totally write ".($hpick+$apick)." sequences (hmm: $hpick | ann: $apick | dicard due to ambiguous alignment: $dirty | dicard due to length: $badSize).\n");
  }
}

# >16S_rRNA::BI00099170_k141_1_flag=1_multi=11.0000_len=2095_C1_(FWD+REV-)_1960:1-1546(+)
sub readBarrnapID{
  my $i = shift;
  my ($region,$bid,$cid,$start,$stop,$strand) = ();
  if($i =~ /^(\S+)_rRNA::(.*BI\d+)_k\d+_(\d+)_.*C([0-9]+|-)_.*:(\d+)-(\d+)\(([+-])\)/){
    ($region,$bid,$cid,$start,$stop,$strand) = ($1,$2,"$2.$3.$4",$5,$6,$7);
  }else{
    ($bid,$cid) = ($i,$i);
  }
  $i =~ s/^(\S+)_rRNA:://;
  return($region,$bid,$cid,$start,$stop,$strand,$i);
}

# >BI00000005_k141_1_flag=1_multi=10.0000_len=356_C-_()_356|G|5.8S Extracted 5.8S sequence (158 bp)
sub readITSxID{
  my $i = shift;
  my ($bid,$cid,$start,$stop,$strand) = ();
  if($i =~ /^(.*BI\d+)_k\d+_(\d+)_.*C([0-9]+|-)_/){
    ($bid,$cid) = ($1,"$1.$2.$3");
  }else{
    ($bid,$cid) = ($i,$i);
  }
  return($bid,$cid);
}

##############################################################################
### maketree: find cluster anno info and make a tree
##############################################################################
sub usage4maketree {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 uch -i fasta -u clust.uc -o output.fa
    -a  bead annotation file (to remove potential hybridize bead)
    -u  cluster file with 10 column
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_maketree {
  &usage4maketree("find cluster anno info and make a tree.") && exit unless @ARGV;
  my ($cut,$ann,$inf,$ucf,$out,$verbose,$help);
  GetOptions(
    "a=s" => \$ann,
    "u=s" => \$ucf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4maketree("Output sequence ID that can be clustered.") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  open ANN, "< $ann" or die $!;
  open UCF, "< $ucf" or die $!;
  #open INF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  my %ANNO;
  while(<ANN>){
    chomp;
    my @s = split "\t";
    my @b = split(/\|/, $s[0]);
    $ANNO{$b[0]} = $_;
  }
  close ANN;

  &verbose("[log] Mode [UCH] start ... \n");
  my(%CLUST);
  #Here is the shorts for each column. Find more detail in VSEARCH manual.
  ##   0         1       2            3            4  5  6      7     8        9##
  ##Type  #Cluster  length  similarity%  orientation  *  *  CIGAR query centroid##
  while(<UCF>){
    chomp;
    next unless /^C/;
    my @s = split "\t";
    my @b8 = split "_",$s[8];
    my $lotu = "LOTU_".($s[1]+1);

    print OUT "$lotu\t$ANNO{$b8[0]}\n";

  }
  close UCF;
  close OUT;
  &verbose("[log] Finish read&write.\n");
}

##############################################################################
### makeTaxon: find cluster anno info and make a tree
##############################################################################
sub usage4maketaxon{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 maketaxon -a annotation -u clust.uc -o output.fa
    -d  default domain [Bacteria]
    -a  bead annotation file (to remove potential hybridize bead)
    -u  cluster file with 10 column
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_maketaxon {
  &usage4maketaxon("find cluster anno info and make a tree.") && exit unless @ARGV;
  my ($dom,$ann,$tax,$ucf,$out,$verbose,$help);
  GetOptions(
    "d=s" => \$dom,
    "a=s" => \$ann,
    "u=s" => \$ucf,
    "t=s" => \$tax,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  $dom||="Bacteria";
  &usage4maketaxon("Output sequence ID that can be clustered.") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  open ANN, "< $ann" or die $!;
  open UCF, "< $ucf" or die $!;
  open TAX, "< $tax" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  open ACC, ($out)?">$out.acc_taxid":"> -" or die $!;
  my %ANNO;
  while(<ANN>){
    chomp;
    my @s = split "\t";
    my @b = split(/\|/, $s[0]);
    if($s[1]=~/^[^0-9]+/ && $s[2] =~ /^\d+/){
      $ANNO{$b[0]} = $s[1];
    }elsif($s[6]=~/^[^0-9]+/ && $s[7] =~ /^\d+/){
      $ANNO{$b[0]} = $s[6];
    }
  }
  close ANN;
  my %TAX;
  while(<TAX>){
    chomp;
    my @s = split "\t";
    my @b = split /;/, $s[0];
    my @n = split /__/,$b[-1];
    $TAX{I}{$s[1]}{L} = $s[2];
    $TAX{I}{$s[1]}{P} = $s[0];
    $TAX{I}{$s[1]}{N} = $n[1];
    $TAX{N}{$n[1]} = $s[1];
    $TAX{MAXID} = ($s[1] > $TAX{MAXID})? $s[1]:$TAX{MAXID};
  }
  close TAX;

  &verbose("[log] Mode [UCH] start ... \n");
  my(%CLUST);
  #Here is the shorts for each column. Find more detail in VSEARCH manual.
  ##   0         1       2            3            4  5  6      7     8        9##
  ##Type  #Cluster  length  similarity%  orientation  *  *  CIGAR query centroid##
  my $no = $TAX{MAXID};
  while(<UCF>){
    chomp;
    next unless /^C/;
    my @s = split "\t";
    my @b8 = split "_",$s[8];
    my $lotu = "LOTU_".($s[1]+1);
    my $lv = "LOTU";#($TAX{I}{$id}{L} eq "species")?"strain":"species";
    $no ++;
    if(exists $ANNO{$b8[0]}){
      if(exists $TAX{N}{$ANNO{$b8[0]}}){
        my $id = $TAX{N}{$ANNO{$b8[0]}};
        print OUT "$TAX{I}{$id}{P}$lotu;\t$no\t$lv\n"
      }else{
        my @pfx = split / /,$ANNO{$b8[0]};
        shift @pfx if $pfx[0] =~ /[Uu]nidentified|[Uu]ncultured|[Uu]nknown/;
        if(exists $TAX{N}{$pfx[0]}){
          my $id = $TAX{N}{$pfx[0]};
          print OUT "$TAX{I}{$id}{P}species__$ANNO{$b8[0]};\t$no\tspecies\n";
          $no ++;
          print OUT "$TAX{I}{$id}{P}species__$ANNO{$b8[0]};$lotu;\t$no\t$lv\n";
        }else{
          print OUT "domain__$dom;species__$ANNO{$b8[0]};\t$no\tspecies\n";
          $no ++;
          print OUT "domain__$dom;species__$ANNO{$b8[0]};$lotu;\t$no\t$lv\n";
        }
      }
    }else{
      print OUT "domain__$dom;$lotu;\t$no\t$lv\n";
    }
    print ACC "$lotu\t$no\n";

  }
  close UCF;
  close OUT;
  close ACC;
  &verbose("[log] Finish read&write.\n");
}


##############################################################################
### kk2prf: generate profile from kraken2
##############################################################################
sub usage4kk2prf{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 kk2prf -a annotation -u clust.uc -o output.fa
    -a  bead annotation file (to remove potential hybridize bead)
    -u  cluster file with 10 column
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
our(%NAMES);
sub run_kk2prf{
  &usage4kk2prf("generate profile from kraken2") && exit unless @ARGV;
  my ($db,$inf,$out);
  GetOptions(
    "d=s" => \$db,
    "i=s" => \$inf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4kk2prf("generate profile from kraken2") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [kk2prf] start ... \n");
  my $pfx = ($out=~/^(.*).prof$/)?$1:$out;
  open KK2, "< $inf" or die $!;
  open DBN, "< $db/taxonomy/names.dmp" or die $!;
  open DBD, "< $db/taxonomy/nodes.dmp" or die $!;
  open TAX, "< $db/taxonomy/paths.txt" or die $!;
  open OUT, ($out)?">$out":">/dev/null" or die $!;
  open OT0, ($out)?">$pfx.0000":">/dev/null" or die $!;
  open OTB, ($out)?">$pfx.bead":">-" or die $!;

  my (%KKX,%KKO,%TMP,$pID,$pHID,$tmpCount);
  &verbose("  Reading names.dmp ... ");
  while(<DBN>){
    chomp;
    my @s = split /\t+\|\t+/;
    $NAMES{$s[0]}{N} = $s[1];
  }
  close DBN;
  &verbose("done.\n  Reading nodes.dmp ... ");
  while(<DBD>){
    chomp;
    my @s = split /\t+\|\t+/;
    if($s[0] == 1) { $s[1] = 0 }
    foreach my $k (keys %{$NAMES{$s[1]}{A}}){ $NAMES{$s[0]}{A}{$k} ++;}
    $NAMES{$s[0]}{A}{$s[1]} ++;
    $NAMES{$s[0]}{P} = $s[1];
    $NAMES{$s[0]}{R} = $s[2];
  }
  close DBD;
  &verbose("done.\n  Reading kraken results ... \n");
  while(<KK2>){
    chomp;
    my @s = split /\t/;
    $s[1] =~ /(\d\d\d\d)_(\d\d\d\d_\d\d\d\d)$/;
    my ($BID,$HID) = ("$1\_$2",$1);
    if ($BID =~ /0000/){
      $KKO{$s[2]} ++;
    }else{
      if($BID ne $pID && $tmpCount > 0 ){
        if($pID eq "0001_0044_0972"){
          my $debug = 1;
        }
        my ($c1st,$c2nd,$totalCount,$dist,%BTMP) = &searchPath(\%TMP);
        die "$pID\n" if $totalCount == 0;
        my $pct = sprintf("%.2f",$BTMP{$c1st} / $totalCount);
        # define: all reads | BID | top hit node | hits | pct. | 2nd hit node | hits| tree distance between hit1 and hit2
        # pct. = hit1 supported reads / all reads
        print OTB "$tmpCount\t$pID\t$c1st\t$TMP{$c1st}\t$pct\t$c2nd\t$TMP{$c2nd}\t$dist\n";
        $KKX{$c1st} ++;
        #
        %TMP = ();
        $tmpCount = 0;
      }
      #count all hit NODES
      my @hits = split / /, $s[4];
      foreach(@hits){
        if($_ =~ /(\d+):(\d+)/){
          my ($n,$c) =  ($1,$2);
          $TMP{$n} +=$c;
        }
      }
      $pID = $BID;
      $tmpCount ++;
    }
    if($pHID ne $HID){
      &verbose("    processing [$HID\_XXXX\_XXXX] ... \r");
    }
    $pHID = $HID;
  }
  close KK2;
  close OTB;
  &verbose("\n  Reading kraken results ... done.\n  bead file written.\n  Reading paths.txt and outputing ... ");
  my %TAX;
  print OT0 sprintf("%8d\t%6d\t%s\t%s\t%s\n",$KKO{0},0,"root","UNCLASSIFIED","root");
  print OUT sprintf("%8d\t%6d\t%s\t%s\t%s\n",$KKX{0},0,"root","UNCLASSIFIED","root");
  while(<TAX>){
    chomp;
    my @s = split "\t";
    my @b = split /;/, $s[0];
    my @n = split /__/,$b[-1];
    if(exists $KKO{$s[1]}){
      print OT0 sprintf("%8d\t%6d\t%s\t%s\t%s\n",$KKO{$s[1]},$s[1],$s[2],$n[-1],$s[0]);
    }
    if(exists $KKX{$s[1]}){
      print OUT sprintf("%8d\t%6d\t%s\t%s\t%s\n",$KKX{$s[1]},$s[1],$s[2],$n[-1],$s[0]);
    }
  }
  close TAX;
  close OUT;
  close OT0;
  &verbose("done.\n  All done!\n");
  return();
}
###############################################################################
sub searchPath{
  my $T = shift @_;
  my (%pickNodes,$totalCount);
  my @nodes = sort {$b<=>$a} keys %$T;
  my $n = shift @nodes;
  $pickNodes{$n} += $$T{$n};
  $totalCount += $$T{$n};
  my @finds = ($n);
  foreach $n (@nodes){
    $totalCount += $$T{$n};
    my ($catchFamily,$catches) = (0,0);
    foreach my $f (@finds){
      if(exists $NAMES{$f}{A}{$n}){
        $pickNodes{$f} += $$T{$n};
        $catches ++;
      }
    }
    if($catches == 0){
      push @finds, $n;
      $pickNodes{$n} += $$T{$n};
    }
  }
  if($totalCount == 0){
    $totalCount =1;
    $pickNodes{0} = 1;
  }
  @finds = sort {$pickNodes{$b}<=>$pickNodes{$a} or $b<=>$a } keys %pickNodes;
  my ($f1st,$f2nd,$dist) = ($finds[0],$finds[0],0);
  if(@finds > 1){
    $f2nd = $finds[1];
    my @parents1 =  sort {$b<=>$a} keys %{$NAMES{$f1st}{A}};
    my @parents2 =  sort {$b<=>$a} keys %{$NAMES{$f2nd}{A}};
    for(my $i=0;$i<@parents1;$i++){
      for(my $j=0;$j<@parents2;$j++){
        if($parents1[$i] eq $parents2[$j]){
          $dist = $i + $j + 2;
          last;
        }
      }
    }
  }
  return($f1st,$f2nd,$totalCount,$dist,%pickNodes);
}

##############################################################################
### sumprf: summarise kraken2 profile to specific rank
##############################################################################
sub usage4sumprf{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 sumprf -r [rank] -i <input.kraken2 profile> -o output.fa
    -r  rank. [domain|phylum|class|order|family|genus|species|LOTU]
    -i  kraken2 profile
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
our(%NAMES);
sub run_sumprf{
  &usage4kk2prf("summarise kraken2 profile to specific rank") && exit unless @ARGV;
  my ($rank,$name,$inf,$out);
  GetOptions(
    "r=s" => \$rank,
    "i=s" => \$inf,
    "n=s" => \$name,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4kk2prf("summarise kraken2 profile to specific rank") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [kk2prf] start ... \n");
  my $pfx = ($out=~/^(.*).prof$/)?$1:$out;
  open KK2, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  if($name){
    open NAME,"<$name" or die $!;
    while(<NAME>){
      chomp;
      my @s = split /[\s\t]*\|[\s\t]*/;
      $s[1] =~ /(\S+)\__(.*)/;
      $NAMES{$s[1]}{rank} = $1;
      $NAMES{$s[1]}{tax} = $2;
      $NAMES{$s[1]}{id} = $s[0];
    }
  }
  my (%KK,%GROUP,%TMP,%LAST,@prePath,$pHID,$tmpCount);
  &verbose("  Reading kraken2 profile ... ");
  while(<KK2>){
    chomp;
    my @s = split /\t/;
    if($s[3] eq "UNCLASSIFIED"){
      print OUT sprintf("%d\t%d\t%s\t%s\n",$s[0],0,"root",$s[3]);
      next;
    }
    my $curRank = $s[2];
    $LAST{$s[3]} = $curRank;
    my @curPath = split /;/,$s[4];
    my ($d,$r) = (-1,);
    for(my $i=0;$i<@curPath;$i++){
      if($curPath[$i] ne $prePath[$i]){$d=$i; last; }
    }
    for(my $i=0;$i<@curPath;$i++){
      if($curPath[$i] =~ /^(\S+)\_\_(.+)$/){
        if($1 eq $rank){$r=$i; last; }
      }else{
        if($LAST{$curPath[$i]} eq $rank){$r=$i;last}
      }
    }
    &sumRank($d,\%TMP,@prePath);
    &addRank(\@s,$d,$r,\%TMP,@curPath);
    @prePath = @curPath;
  }
  &sumRank(0,\%TMP,@prePath);
  close KK2;

  &verbose("done.\n  Writing ...");
  foreach my $tax (sort keys %{$TMP{count}}){
    if($TMP{count}{$tax} >0){
      print OUT sprintf("%d\t%d\t%s\t%s\n",$TMP{count}{$tax},$TMP{uniqID}{$tax},$TMP{rank}{$tax},$tax);
    }
  }
  return();
}

sub sumRank{
  my ($d,$T,@prePath) = @_;
  if($d >= 0){
    for(my $i=$#prePath;$i>=$d;$i--){
      my $parent = $prePath[$i];
      if(exists $$T{relation}{$prePath[$i]}{ChildMember}){
        foreach my $c (sort keys %{$$T{relation}{$prePath[$i]}{ChildMember}} ){
          $$T{count}{$c} += $$T{count}{$prePath[$i]} * ($$T{count}{$c}/$$T{relation}{$prePath[$i]}{ChildCount})
        }
        $$T{count}{$prePath[$i]} = 0;
      }
    }
  }
}
sub addRank{
  my ($c,$d,$r,$T,@curPath) = @_;
  my $e;
  if($r){
    $e = $r;
  }elsif($curPath[-1] =~ /^(\S+)\_\_(.+)$/){
    $e = $#curPath;
  }else{
    $e= $#curPath -1;
  }
  #my $e = ($r)?$r:$#curPath;
  for(my $i=0;$i<$e;$i++){
    $$T{relation}{$curPath[$i]}{ChildMember}{$curPath[$e]} ++;
    $$T{relation}{$curPath[$i]}{ChildCount} += $$c[0];
  }
  if($e < $#curPath && exists $NAMES{$curPath[$e]}){
    $$T{count}{$curPath[$e]} += $$c[0];
    $$T{rank}{$curPath[$e]} ||= $NAMES{$curPath[$e]}{rank};
    $$T{uniqID}{$curPath[$e]} ||= $NAMES{$curPath[$e]}{id};
  }else{
    $$T{count}{$curPath[$e]} += $$c[0];
    $$T{rank}{$curPath[$e]} ||= $$c[2];
    $$T{uniqID}{$curPath[$e]} ||= $$c[1];
  }
}

##############################################################################
### sumgff: summarise gff file from barrnap results
##############################################################################
sub usage4sumgff{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 sumgff -i <barrnap gff3> -o output.tsv
    -i  barrnap gff3 file
    -d  domain. [bac|euk]
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
our(%NAMES);
sub run_sumgff{
  &usage4sumgff("summarise gff file from barrnap results") && exit unless @ARGV;
  my ($rank,$dom,$inf,$out);
  GetOptions(
    "i=s" => \$inf,
    "d=s" => \$dom,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  $dom ||= "bac";
  my @units = ($dom =~ /[Bb]ac/)?("16S","23S","5S"):("18S","28S","5.8S");
  &usage4kk2prf("summarise gff file from barrnap results") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [sumgff] start ... \n");
  open GFF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  my %SCORE = ('16S'=>1,'18S'=>1,'5.8S'=>2,'5S'=>2,'23S'=>4,'28S'=>4);
  my (%BD,$pBI,$pCI);
  &verbose("  Reading gff ... ");
  while(<GFF>){
    chomp;
    next if /^#/;
    my @s = split /\t/;
    my @b = split /_/,$s[0];
    my ($uLen,$prod,$pct) = ($s[4] - $s[3], "NA", 0);
    if($pBI && $pBI ne $b[0]){
      print OUT "$pBI";
      my $score = 0;
      foreach my $u (@units){
        my ($l,$p) = (0,0);
        if($BD{$u}){
          ($l,$p) = ($BD{$u}{L},$BD{$u}{P});
          $score += $SCORE{$u}
        }
        print OUT "\t$l\t$p";
      }
      print OUT "\t$score\n";
      %BD = ();
    }
    if($s[8]=~/product=(\S+) ribosomal RNA/){
      $prod = $1; $pct = 100;
    }
    if($s[8]=~/note=aligned only (\d+) percent/){
      $pct = $1;
    }
    ($BD{$prod}{L},$BD{$prod}{P}) = ($pct > $BD{$b[0]}{$prod})?($uLen,$pct):($BD{$prod}{L},$BD{$prod}{P});

    ($pBI,$pCI) = ($b[0],$b[2]);
  }
  close GFF;
  close OUT;
  return();
}

##############################################################################
### itsx: summarise itsx position.txt info
##############################################################################
sub usage4itsx{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 itsx -i <barrnap gff3> -o output.tsv
    -i  itsx position file
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_itsx{
  &usage4itsx("summarise itsx position.txt info") && exit unless @ARGV;
  my ($rank,$inf,$out);
  GetOptions(
    "i=s" => \$inf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4kk2prf("summarise itsx position.txt info") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [itsx] start ... \n");
  open ITS, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  my %SCORE = ("SSU"=>1,"ITS1-2"=>2,'LSU'=>4);
  my %SCOREITS = ("ITS1"=>1,'5.8S'=>2,"ITS2"=>4);
  my %BD = ("SSU"=>0,"ITS1"=>0,'5.8S'=>0,"ITS2"=>0,'LSU'=>0);
  my ($score,$scoreits,$pBI,$pCI) = (0, 0, , );
  &verbose("  Reading ITSx position.txt ... ");
  while(<ITS>){
    chomp;
    next if /^#|Chimeric/;
    my @s = split /\t/;
    my @b = split /_/,$s[0];
    $s[1] =~ s/ bp.//;
    if($pBI && $pBI ne $b[0]){
      print OUT "$pBI";
      foreach my $u ("SSU","ITS1","5.8S","ITS2","LSU"){
        print OUT "\t$BD{$u}";
      }
      print OUT "\t$score\t$scoreits\n";
      %BD = ("SSU"=>0,"ITS1"=>0,'5.8S'=>0,"ITS2"=>0,'LSU'=>0);
      ($score,$scoreits)=(0,0)
    }
    for(my $i=2;$i<7;$i++){
      if($s[$i] =~/(\S+): (\d+)-(\d+)/){
        my ($unit,$ulen) = ($1, $3 - $2 + 1);
        my $unit1 = ($unit=~/ITS|5.8S/)?"ITS1-2":$unit;
        if($BD{$unit} == 0){
          unless($unit=~/ITS|5.8S/ && $BD{"ITS1"} + $BD{"5.8S"} + $BD{"ITS2"} > 0){
             $score += $SCORE{$unit1}
           }
           $scoreits += $SCOREITS{$unit} if exists $SCOREITS{$unit};
           $BD{$unit} = $ulen;
        }else{
          $BD{$unit} = $ulen if $ulen > $BD{$unit};
        }
      }elsif($s[$i] =~/(\S+): No end/){
        my ($unit,$ulen,$start,$end) = ($1,0,0,$s[1]);
        my $unit1 = ($unit=~/ITS|5.8S/)?"ITS1-2":$unit;
        if($s[$i-1] =~/(\S+): (\d+)-(\d+)/){
          $start = $3 + 1;
        }
        if($s[$i+1] =~/(\S+): (\d+)-(\d+)/){
          $end = $2 - 1;
        }
        $ulen = $end - $start + 1;
        if($BD{$unit} == 0){
          $score += $SCORE{$unit1} if $BD{"ITS1"} + $BD{"5.8S"} + $BD{"ITS2"} == 0;
          $scoreits += $SCOREITS{$unit} if exists $SCOREITS{$unit};
          $BD{$unit} = $ulen;
        }else{
          $BD{$unit} = $ulen if $ulen > $BD{$unit};
        }
      }
    }
    ($pBI,$pCI) = ($b[0],$b[2]);
  }
  close ITS;
  close OUT;
  return();
}


##############################################################################
### uc2fa: get forward strand of barrnaped sequence from vsearch cluster file
##############################################################################
sub usage4uc2fa{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 uc2fa -i <fa file>  -u <uc file> -o output.fa
    -i  fa file
    -u  uc file
    -m  minimum length allowed
    -t  tag/label, default "OTU_"
    -a  anno file to change ID
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_uc2fa{
  &usage4uc2fa("get forward strand of barrnaped sequence from vsearch cluster file") && exit unless @ARGV;
  my ($rank,$inf,$anno,$inu,$tag,$min,$out);
  GetOptions(
    "i=s" => \$inf,
    "u=s" => \$inu,
    "m=f" => \$min,
    "a:s" => \$anno,
    "t=s" => \$tag,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4uc2fa("get forward strand of barrnaped sequence from vsearch cluster file") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[uc2fa] Mode start\n");
  my (%CLUST,%SEQ,%MAP);
  open INU, "< $inu" or die $!;
  open INF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  if($anno){
    &verbose("  Reading $anno ... ");
    open ANN,"< $anno" or die $!;
    while(<ANN>){
      chomp;
      my @s = split /\t/;
      $s[0] =~ /^(\S+_k\d+_\d+)/;
      $MAP{$1} = $s[-3];
    }
    &verbose("done\n")
  }
  &verbose("  Reading $inu ... ");
  while(<INU>){
    chomp;
    my @s = split /\t/;
    next unless $s[0] eq "S" && $s[2] >= $min;
    die "cannot recoganize id string!\n" unless @s[8] =~ /^(\S+_k\d+_\d+)_.+\(([+-])\)/;
    my ($BID,$strand) = ($1,$2);
    $CLUST{$s[8]}{BID} = $BID;
    $CLUST{$s[8]}{STR} = $strand;
    $CLUST{$s[8]}{ORD} = $s[1] + 1;
  }
  close INU;
  &verbose("done\n  Reading $inf ... ");
  $/=">";
  while(<INF>){
    chomp;
    next unless $_;
    my @s = split /\n/;
    my $id = shift @s;
    my $seq = join("",@s);
    next unless exists $CLUST{$id};
    $SEQ{$CLUST{$id}{ORD}}{ID} = (exists $MAP{$CLUST{$id}{BID}})?$MAP{$CLUST{$id}{BID}}:$tag.$CLUST{$id}{ORD};
    $SEQ{$CLUST{$id}{ORD}}{SEQ} = ($CLUST{$id}{STR} eq "+")?$seq:&xDNA("rc",$seq);
  }
  close INF;
  &verbose("done\n  writing ... ");
  foreach my $no (sort {$a<=>$b} keys %SEQ){
    print OUT ">$SEQ{$no}{ID}\n$SEQ{$no}{SEQ}\n";
  }
  close OUT;
  &verbose("done\n");
  return();
}

sub xDNA{
  my ($mod,$str) = @_;
  my %SH;
  for(my $p=0;$p<length($str);$p++){
    my $pick = substr($str,$p,1);
    my $comp = ($pick eq "A")?"T":(($pick eq "T")?"A":(($pick eq "G")?"C":(($pick eq "C")?"G":$pick)));
    $SH{$p}{'raw'} = $pick;
    $SH{$p}{'com'} = $comp;
  }
  my $res = "";
  if($mod =~ /r/){
    foreach my $p (sort {$b<=>$a} %SH){
      $res .= ($mod =~/c/)?$SH{$p}{'com'}:$SH{$p}{'raw'};
    }
  }else{
    foreach my $p (sort {$a<=>$b} %SH){
      $res .= ($mod =~/c/)?$SH{$p}{'com'}:$SH{$p}{'raw'};
    }
  }
  return($res);
}


##############################################################################
### treeAnno: find and replace with annotation of tree nodes id
##############################################################################
sub usage4treeAnno{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 treeanno -t <tree> -a <anno file> -u <uc file> -o <new tree>
    -i  fa file
    -u  uc file
    -m  minimum length allowed
    -t  tag/label, default "OTU_"
    -a  anno file to change ID
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_treeAnno{
  &usage4treeAnno("find and replace with annotation of tree nodes id") && exit unless @ARGV;
  my ($rank,$inf,$anno,$inu,$tag,$min,$out);
  GetOptions(
    "i=s" => \$inf,
    "u=s" => \$inu,
    "m=f" => \$min,
    "a:s" => \$anno,
    "t=s" => \$tag,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4treeAnno("find and replace with annotation of tree nodes id") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[treeAnno] Mode start\n");
  my (%CLUST,%SEQ,%MAP);
  $tag ||= "OTU_";
  open INU, "< $inu" or die $!;
  open INF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  open ANN,"< $anno" or die $!;
  &verbose("  Reading $anno ... ");
  while(<ANN>){
    chomp;
    my @s = split /\t/;
    $s[0] =~ /^(\S+_k\d+_\d+)/;
    $MAP{$1} = $s[-3];
  }
  &verbose("done\n  Reading $inu ... ");
  while(<INU>){
    chomp;
    my @s = split /\t/;
    next unless $s[0] eq "S" && $s[2] >= $min;
    die "cannot recoganize id string!\n" unless @s[8] =~ /^(\S+_k\d+_\d+)_.+\(([+-])\)/;
    my ($BID,$strand) = ($1,$2);
    $CLUST{$s[1]+1} = $BID;
  }
  close INU;
  &verbose("done\n  Reading $inf ... ");
  $/=$tag;
  while(<INF>){
    chomp;
    $_ =~ s/^(\d+)//;
    my $otu = $1;
    if( exists $MAP{$CLUST{$otu}}){
      print OUT $MAP{$CLUST{$otu}}.$_;
    }else{
      print OUT $otu.$_.$tag;
    }
  }
  close INF;
  close OUT;
  &verbose("done\n");
  return();
}

##############################################################################
### printUniqSubunit: print bead's subunits seqs
##############################################################################
sub run_printUniqSubunit{
  my ($inf,$tag,$out);
  GetOptions(
    "i=s" => \$inf,
    "t=s" => \$tag,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  #&usage("[fatal] Essential input is missing");
  &verbose("[printUniqSubunit] start\n");
  open INF, "< $inf" or die $!;
  open OUT, "> $out" or die $!;
  &verbose("  Reading $inf ... ");
  my $ori = $/; $/ = ">";
  my (%SEQ,@ORDER);
  while(<INF>){
    next unless $_ =~/$tag/;
    chomp;
    my @s = split /\n/;
    my $sid = shift @s;
    my $seq = join("\n",@s);
    my $len = length($seq);
    next unless $len > 999;
    $sid =~ s/^.*:://;
    #$sid =~/^(.*BI\d+)_k\d+_(\d+)_.*_(C[0-9\-])_/;
    #$SEQ{"$1.$2.$3"}{$sid} = $seq;
    #push @ORDER, "$1.$2.$3";
    print OUT ">$sid\n$seq\n";
  }
  close INF;
  # &verbose("Done\n  writing ... ");
  # while(@ORDER){
  #   my $b = shift @ORDER;
  #   #my @c = keys %{$SEQ{$b}};
  #   #next if scalar @c > 1;
  #   foreach my $c (sort keys %{$SEQ{$b}}){
  #     print OUT ">$c\n$SEQ{$b}{$c}\n";
  #   }
  # }
  close OUT;
  &verbose("DONE!\n");
}
##############################################################################
### extractITSxSubunits: print each subunits from ITSx prediction (for euk)
##############################################################################
sub run_printITSxSubunit{
  my ($inf,$pos,$out);
  GetOptions(
    "i=s" => \$inf,
    "p=s" => \$pos,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  #&usage("[fatal] Essential input is missing");
  &verbose("[printITSxSubunit] start\n");
  open INF, "< $inf" or die $!;
  open POS, "< $pos" or die $!;
  open SSU, "> $out.SSU.fasta" or die $!;
  open LSU, "> $out.LSU.fasta" or die $!;
  &verbose("  Reading $pos ... ");
  my (%POS,%SEQ,@ORDER);
  while(<POS>){
    next if $_ =~ /Chimeric/;
    chomp;
    my @s = split /\t/;
    my $id = shift @s;
    my $slen = shift @s;
    next if $slen < 1000;
    while(@s){
      my $str = shift @s;
      if($str =~ /(\S+): (\d+)-(\d+)/ ){
        my ($unit,$offset,$len) = ($1,$2-1,$3-$2+1);
        $POS{$id}{$unit}{O} = $offset;
        $POS{$id}{$unit}{L} = $len;
      }
    }
  }
  close POS;
  &verbose("done!\n  Reading $inf ... ");
  my $ori = $/; $/ = ">";
  while(<INF>){
    chomp;
    my @s = split /\n/;
    my $sid = shift @s;
    next unless exists $POS{$sid};
    my $seq = join("\n",@s);
    my $len = length($seq);
    #SSU
    if($POS{$sid}{"SSU"}{L} > 999){
      my $ssu = substr($seq,$POS{$sid}{"SSU"}{O},$POS{$sid}{"SSU"}{L});
      print SSU ">$sid\n$ssu\n";
    }
    #LSU
    if($POS{$sid}{"LSU"}{L} > 999){
      my $lsu = substr($seq,$POS{$sid}{"LSU"}{O},$POS{$sid}{"LSU"}{L});
      print LSU ">$sid\n$lsu\n";
    }
  }
  close INF;
  close SSU;
  close LSU;
  &verbose("DONE!\n");
}
##############################################################################
### makeClade: cluster SSU/LSU into clades with specific identity of similairty
##############################################################################
sub usage4makeClade{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 makeClade -t <tree> -d <identities> -o <output prefix>
    -i  fa file
    -d  identities. [0.9,0.95,0.97,0.99,0.995]
    -t  threads. default [1]
    -o  output prefix
    -v  verbose
    -h  show help info
USAGE
}
our(%UC);
sub run_makeClade{
  &usage4makeClade("cluster SSU/LSU into clades with specific identity of similairty") && exit unless @ARGV;
  my ($inf,$ids,$cpu,$ann,$out);
  GetOptions(
    "i=s" => \$inf,
    "d=s" => \$ids,
    "t:f" => \$cpu,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4makeClade("cluster SSU/LSU into clades with specific identity of similairty") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[makeClade] Mode start\n");
  my (%SEQ);
  $ids ||= "0.4,0.5,0.66,0.72,0.77,0.83,0.89,0.92,0.95,0.97,0.98,0.99,0.995,0.999,1";
  $cpu ||= 1;
  my @ids = split /,/,$ids;
  open INF, "< $inf" or die $!;
  &verbose("  Reading $inf ... ");
  my $ori = $/; $/ = ">";
  while(<INF>){
    chomp; next unless $_;
    my @s = split /\n/;
    my $sid = shift @s;
    $sid = (split /\t|\s/, $sid)[0];
    my $seq = join("\n",@s);
    $SEQ{$sid} = $seq;
  }
  close INF;
  &verbose("DONE!\n");

  $/=$ori;
  chomp(my $ramtmp=("-e /dev/shm")?`mktemp -d /dev/shm/otupair.XXXXXXXXXX`:"mktemp -dp $out.XXX");
  my $pid = 0;
  while(@ids){
    my $id = pop @ids;
    my $inputfile = "";
    open OUT, ($out)?">$out\_$id":">-" or die $!;
    if($pid !=0){
      my $counts = scalar (keys %{$UC{$pid}});
      my $count = 0;
      open TMP, ">$ramtmp/tmp.fa" or die $!;
      foreach my $c (sort {$a<=>$b} keys %{$UC{$pid}}){
        #next if $UC{$pid}{$c}{N} < 2;
        $count ++;
        print TMP ">$c\n$SEQ{$c}\n";
        # foreach my $m (sort keys %{$UC{$pid}{$c}{M}}){
        #   $count ++;
        #   print TMP ">$m\n$SEQ{$m}\n";
        # }
      }
      close TMP;
      $inputfile = "$ramtmp/tmp.fa";
    }else{
      $inputfile = $inf;
    }
    #$inputfile = $inf;
    my $cmd = "vsearch --threads $cpu --cluster_fast $inputfile --iddef 2 --id $id --strand both --uc - ";
    &verbose("  Clustering at $id [$cmd] \n");
    &readUC($id,$cmd);
    $pid = $id;
  }
  return();
}

sub readUC{
  my ($id,$cmd) = @_;
  open UC,"$cmd|" or die $!;
  while(<UC>){
    print OUT $_;
    chomp;
    my @u = split /\t/;
    #next unless $u[0] eq "H";
    if($u[0] eq "S"){
      $UC{$id}{$u[8]}{L} = $u[2];
    }elsif($u[0] eq "H"){
      $UC{$id}{$u[9]}{M}{$u[8]}{I} = $u[3];
      $UC{$id}{$u[9]}{M}{$u[8]}{L} = $u[2];
    }elsif($u[0] eq "C"){
      $UC{$id}{$u[8]}{N} = $u[2];
    }
  }
  close UC;
}


##############################################################################
### clade2tree: generate a path tree from vsearch uc file
##############################################################################
sub usage4clade2tree{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 clade2tree -a <annotation file> -d <db path> -s <ssu clusters prefix> -o <output>
    -i  beads sequence file (just read ID);
    -a  annotation file
    -d  kraken2 database location with custom preprared files:
          <db>/taxonomy/paths.txt
          <db>/seqid2taxid.map
          <db>/data/vsearch.allpair.txt
    -s  units clusters prefix
    -p  print path with taxname[tax] or clade name(default)[clade].
    -m  mode of cutoff for default genus and species clade. Default is [bac]
          bac: 0.97 for genus and 0.99 for species, according to SSU and LSU distribution.
          euk: 0.95 for genus and 0.97 for species, according to ITS distribution.
    -o  output db dir
    -v  verbose
    -h  show help info
USAGE
}
our($DEFAULT_GE,$DEFAULT_SP,%ANNO,%MAP,%DBTREE,%RANKI,%SEQ,$rankID,%OCC);
$rankID = 1;
sub run_clade2tree{
  &usage4clade2tree("generate a path tree from vsearch uc file") && exit unless @ARGV;
  my ($seq,$ann,$db,$toc,$upfx,$ids,$lsu,$pmode,$out);
  GetOptions(
    "i=s" => \$seq,
    "a=s" => \$ann,
    "d=s" => \$db,
    "s=s" => \$upfx,
    "p=s" => \$toc,
    "m=s" => \$pmode,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4clade2tree("generate a path tree from vsearch uc file") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[clade2tree] start\n  Initaiating ... ");
  my(%TREE,%CLADE,%CLADEINIT);
  $toc   ||= "clade";
  $pmode ||= "bac";
  ($DEFAULT_GE,$DEFAULT_SP) = ($pmode eq "bac")?(0.97,0.99):(0.95,0.97);
  &verbose("\n    Mode:$pmode. Using default cuoff of genus:$DEFAULT_GE and species:$DEFAULT_SP ... ");
  #$units ||= "ssu,its,lsu";
  $ids ||= "0.4,0.5,0.66,0.72,0.77,0.83,0.89,0.92,0.95,0.97,0.98,0.99,0.995,0.999,1";
  #&verbose("mode:$pmode | units:$units ... ");
  my %DEFAULT_IDENTITY = ("domain",0.66,"major_clade",0.68,"kingdom",0.7,"phylum",0.76,
  "class",0.77,"order",0.83,"family",0.89,"genus",$DEFAULT_GE,"species",$DEFAULT_SP);
  if($out){
    system("mkdir -p $out/{data,library}");
    open OUT, ">$out/data/raw.txt" or die $!;
    #open FIN, "> $out/data/added.txt" or die $!;
    open TID, ">$out/data/added.acc_taxid" or die $!;
    open FNA, ">$out/library/added.fna" or die $!;
  }else{
    mkdir -p "./{data,library}";
    open OUT, "> data/raw.txt" or die $!;
    #open FIN, "> data/added.txt" or die $!;
    open TID, "> data/added.acc_taxid" or die $!;
    open FNA, "> library/added.fna" or die $!;

  }

  &verbose("done\n  Reading [bead] $seq ... ");
  open SEQ,"< $seq" or die $!;
  my $ori = $/; $/ = ">";
  while(<SEQ>){
    chomp; next unless $_;
    my @s = split /\n/;
    my $id = shift @s;
    $id = (split /\t|\s/,$id)[0];
    my $seq = join("\n",@s);
    my $CID = &getBID($id);
    $SEQ{$CID}{$CID} = $seq;
  }
  $/ = $ori;
  close SEQ;

  #my @units = split /,/,$units;
  my $cladeInit = 1;
  if($db){
    &verbose("done\n  Reading [db] seqid2taxid.map ... ");
    open MAP,"< $db/seqid2taxid.map" or die $!;
    while(<MAP>){
      chomp;
      my @s=split /\t/;
      $MAP{S}{$s[0]} = $s[1];
      $MAP{D}{$s[1]} = $s[0];
      #for BEAD+SUS: add pub seqs into tree
      $ANNO{$s[0]}{uniq} = "unique";
      $ANNO{$s[0]}{ID} = $s[0];
      $ANNO{$s[0]}{ident} = 1;
    }
    &verbose("done\n  Reading [db] taxonomy/paths.txt ... ");
    open TRE,"< $db/taxonomy/paths.txt" or die $!;
    while(<TRE>){
      chomp;
      my @s=split /\t/;
      my @t= split /;/,$s[0];
      $DBTREE{$s[1]}{path} = $s[0];
      $DBTREE{$s[1]}{name} = $t[-1];
      $DBTREE{$s[1]}{rank} = $s[-1];
      $DBTREE{index}{$t[-1]} = $s[1];
      $DBTREE{indexs}{$t[-1]}{$s[1]} = $t[-2];

      $t[-1] =~s/^(\S+)__//;
      $DBTREE{quickIndex}{$t[-1]} = (defined $DBTREE{quickIndex}{$t[-1]})?"":$s[1];
      $DBTREE{MAXID} = ($s[1] > $DBTREE{MAXID})? $s[1]:$DBTREE{MAXID};
      #$TREE{$s[1]}{names} = [@t];
    }
    close TRE;
    $rankID = $DBTREE{MAXID};
  }
  if($ann){
    &verbose("done\n  Reading [bead] $ann ... ");
    open ANN, "< $ann" or die $!;
    while(<ANN>){
      chomp;
      my @s = split "\t";
      my @b = split(/\|/, $s[0]);
      my $CID = &getBID($b[0]);
      next unless $s[19] eq "unique";
      my %TMP;
      $TMP{ssu} = ($s[17]=~/SSU\((\d+)\)/)?$1:0;
      $TMP{lsu} = ($s[17]=~/LSU\((\d+)\)/)?$1:0;
      $TMP{its} = ($s[17]=~/ITS\((\d+)\)/)?$1:0;
      my @ord = sort {$TMP{$b} <=> $TMP{$a}} keys %TMP;
      $ANNO{$CID}{U} = $ord[0];
      $ANNO{$CID}{A} = $_;
      $ANNO{$CID}{ID} = $s[18];
      $ANNO{$CID}{uniq} = $s[19];
      $ANNO{$CID}{tax} = $s[1];
      $ANNO{$CID}{ident} = $s[2];
      $ANNO{$CID}{level} = "CLIP";
    }
    close ANN;
  }
  &verbose("done\n  Reading UC files: ");
  my @ids = split /,/,$ids;
  $cladeInit = ($cladeInit<$ids[0])?$cladeInit:$ids[0];
  my ($pCladeLv,$cladeNo0)=("",0);
  my $lastID = 0;
  my $firstID = $ids[-1];
  while(@ids){
    my $id = pop @ids;
    my $nextID = ($ids[-1])?$ids[-1]:0;
    open SUC, "<$upfx\_$id" or next;
    my $cladeLv = "CLADE$id";
    my $cladeLvLast = "CLADE$lastID";
    my $cladeLvNext = (@ids)?"CLADE$ids[0]":"CLADEFINAL";
    my $cladeNo = 0;
    &verbose("$id ");
    while(<SUC>){
      chomp;
      #next unless $_ =~ /^H/;
      my @s = split /\t/;
      if($s[0] eq "S"){
        my $BID = &getBID($s[8]);

        $cladeNo ++;
        $CLADE{$cladeLv}{$BID}{No} = $cladeNo;
        my $cladeName = $cladeLv."__".$CLADE{$cladeLv}{$BID}{No};
        #assign for current level
        $TREE{$cladeName}{cladeLv} = $cladeLv;
        # check whether this clade has a child clade
        if(exists $CLADE{$cladeLvLast}{$BID}){
          my $cladeChild = $cladeLvLast."__".$CLADE{$cladeLvLast}{$BID}{No};
          $TREE{$cladeName}{children}{$cladeChild} ++ ;
          $TREE{$cladeChild}{parent}{$cladeName} ++;
          # add child clade's annotation
          foreach my $b (sort keys %{$CLADE{$cladeLvLast}{$BID}{ANN}}){
            $CLADE{$cladeLv}{$BID}{ANN}{$b} = $ANNO{$b}{ident};
          }
        }else{
          $TREE{$cladeName}{members}{$BID} ++;
          # add unique annotation
          if($ANNO{$BID}{uniq} eq "unique"){
            $CLADE{$cladeLv}{$BID}{ANN}{$BID} = $ANNO{$BID}{ident};
          }
          $CLADE{$cladeLv}{$BID}{PBA}{$BID} ++;
        }
      }elsif($s[0] eq "H"){
        my $BID8 = &getBID($s[8]);
        my $BID9 = &getBID($s[9]);

        if(exists $CLADE{$cladeLv}{$BID8}{No} ){
          die "$BID8 already presented. Check again.\n";
        }
        $CLADE{$cladeLv}{$BID8}{No} = $CLADE{$cladeLv}{$BID9}{No};
        my $cladeName = $cladeLv."__".$CLADE{$cladeLv}{$BID9}{No};
        # check whether this clade has a child clade
        if(exists $CLADE{$cladeLvLast}{$BID8}){
          my $cladeChild = $cladeLvLast."__".$CLADE{$cladeLvLast}{$BID8}{No};
          $TREE{$cladeName}{children}{$cladeChild} ++ ;
          $TREE{$cladeChild}{parent}{$cladeName} ++;
          # add child clade's annotation
          foreach my $b (sort keys %{$CLADE{$cladeLvLast}{$BID8}{ANN}}){
            $CLADE{$cladeLv}{$BID9}{ANN}{$b} = $ANNO{$b}{ident};
          }
        }else{
          $TREE{$cladeName}{members}{$BID8} ++;
          # add unique annotation
          if($ANNO{$BID8}{uniq} eq "unique"){
            $CLADE{$cladeLv}{$BID9}{ANN}{$BID8} = $ANNO{$BID8}{ident};
          }
          $CLADE{$cladeLv}{$BID9}{PBA}{$BID8} ++;
        }
      }elsif($s[0] eq "C"){
        my $BID = &getBID($s[8]);
        my $cladeName = $cladeLv."__".$CLADE{$cladeLv}{$BID}{No};
        if($cladeName =~ /CLADE0.4__1|CLADE0.5__1|CLADE0.66__1|CLADE0.72__1|CLADE0.77__134|CLADE0.83__393|CLADE0.89__2704|CLADE0.92__4451|CLADE0.95__7198|CLADE0.97__10203|CLADE0.98__12507|CLADE0.99__15891|CLADE0.995__19365|CLADE0.999__29152|CLADE1__31794/){
          my $debug = 1;
        }
        if(exists $TREE{$cladeName}{BID}){
          die "Duplicate cladeName ($cladeName by $BID vs. $TREE{$cladeName}{BID}) found! Check your data.\n";
        }
        #pick proper nodes from merged taxon tree
        my (%PICKS,$totalPick,$maxPick,$maxRank,$PBAmembers);
        my ($topTax,$topRank,$topRatio,$topChildTax,$topChildRank,$topChildRatio,@topChilds) = ("",0,0,"",2,0.5,());
        if($id eq $firstID){
          $PBAmembers = scalar keys %{$CLADE{$cladeLv}{$BID}{PBA}};
        }
        foreach my $bid (sort keys %{$CLADE{$cladeLv}{$BID}{ANN}}){
          my $taxid = $MAP{S}{$ANNO{$bid}{ID}};
          unless($taxid){
            $taxid = $DBTREE{quickIndex}{$ANNO{$bid}{tax}};
          }
          next if $ANNO{$bid}{ident} < $id * 100;
          $totalPick ++;
          my @trees = split /;/,$DBTREE{$taxid}{path};
          #my @nodes;
          my $unit = $ANNO{$bid}{U};

          for(my $i=0;$i<@trees;$i++){
            my $t = $trees[$i];
            (my $r = $t) =~ s/__.*$//;
            next if $t =~ /[Uu]nknown|[Uu]nculture|sp\.$/;
            next if (keys %{$DBTREE{indexs}{$t}}) > 1; #skip if this tax name have multiple IDs.
            next unless $DEFAULT_IDENTITY{$r} &&
            $DEFAULT_IDENTITY{$r} *100 < $ANNO{$bid}{ident} &&
            $DEFAULT_IDENTITY{$r}  > $id - 0.3;

            $PICKS{$DEFAULT_IDENTITY{$r}}{$t} ++ ;
            if($PICKS{$DEFAULT_IDENTITY{$r}}{$t} >= $maxPick){
              $maxPick = $PICKS{$DEFAULT_IDENTITY{$r}}{$t};
              $maxRank = $DEFAULT_IDENTITY{$r};
            }
          }
        }
        # pick top children rank
        foreach my $child (sort {$TREE{$a}{rankScore}<=>$TREE{$b}{rankScore}} keys %{$TREE{$cladeName}{children}}){
          if(exists $TREE{$child}{rankScore} && $TREE{$child}{rankScore} < $topChildRank && $TREE{$child}{rankRatio} > $topChildRatio){
            $topChildRank = $TREE{$child}{rankScore};
            $topChildTax  = $TREE{$child}{UNDERTAX};
            $topChildRatio= $TREE{$child}{rankRatio};
            push @topChilds, $child;
          }elsif(exists $TREE{$child}{rankScore} && $TREE{$child}{rankScore} eq $topChildRank){
            push @topChilds, $child;
          }
          $PBAmembers += $TREE{$child}{PBAmembers};
        }
        #
        if(keys %PICKS > 0){
          unless(@topChilds){
            # pick top children's children rank
            foreach my $child2 (sort keys %{$TREE{$cladeName}{children}}){
              foreach my $child (sort {$TREE{$a}{rankScore}<=>$TREE{$b}{rankScore}} @{$TREE{$child2}{children2}}){
                if(exists $TREE{$child}{rankScore} && $TREE{$child}{rankScore} < $topChildRank && $TREE{$child}{rankRatio} > $topChildRatio){
                  $topChildRank = $TREE{$child}{rankScore};
                  $topChildTax  = $TREE{$child}{UNDERTAX};
                  $topChildRatio= $TREE{$child}{rankRatio};
                  push @topChilds, $child;
                }elsif(exists $TREE{$child}{rankScore} && $TREE{$child}{rankScore} eq $topChildRank){
                  push @topChilds, $child;
                }
              }
            }
          }
          # pick top clade rank
          foreach my $r (sort {$b <=> $a} keys %PICKS){
            if($r > $topChildRank||$r>$maxRank){
              next;
            }else{
              foreach my $t (sort keys %{$PICKS{$r}}){
                # check whether the most picked taxon is dominant
                my $pickRatio = $PICKS{$r}{$t}/$totalPick;
                if($r eq $topChildRank){
                  if($pickRatio >= $topChildRatio * 0.95){
                    $topTax  = $t;
                    $topRank = $r;
                    $topRatio= $pickRatio;
                    # avoid duplicate ranks
                    for(@topChilds){
                      delete $TREE{$_}{rankScore};
                      delete $TREE{$_}{UNDERTAX};
                      delete $TREE{$_}{cladeLv};
                      delete $TREE{$_}{UNDERPATH};
                      $rankID ++;
                      $TREE{$_}{rankID} = $rankID;
                    }
                    last;
                  }
                }else{
                  if($PICKS{$r}{$t} >= $maxPick * 0.98){
                    $topTax  = $t;
                    $topRank = $r;
                    $topRatio= $pickRatio;
                    last;
                  }
                }
              }
              last if $topRatio;
            }
          }
          # summary
          if($topRatio){  # assign top rank
            $CLADE{$cladeLv}{$BID}{Node} = $topTax;
            $TREE{$cladeName}{BID} = $BID;
            $TREE{$cladeName}{UNDERTAX} = $topTax;
            $TREE{$cladeName}{UNDERPATH} = $DBTREE{$DBTREE{index}{$topTax}}{path};
            $TREE{$cladeName}{cladeLv} = $DBTREE{$DBTREE{index}{$topTax}}{rank};
            $TREE{$cladeName}{rankID} = $DBTREE{index}{$topTax};
            $TREE{$cladeName}{rankScore} = $topRank;
            $TREE{$cladeName}{rankRatio} = $topRatio;
          }else{
            $rankID ++;
            $TREE{$cladeName}{rankID} = $rankID;
          }
        }else{
          $rankID ++;
          $TREE{$cladeName}{rankID} = $rankID;
        }

        $CLADE{$cladeLv}{NODES}{$cladeName} ++;
        $TREE{$cladeName}{PBAmembers} = $PBAmembers;
        $TREE{$cladeName}{presentID} = $BID;
        @{$TREE{$cladeName}{children2}} = @topChilds;
        if($PBAmembers<1){
          my $debug = 1;
        }
      }
      # end of "^C"
    }
    $lastID = $id;
  }
  #assign all members

  &verbose("done\n  Writing ... ");

  foreach my $c (sort keys %{$CLADE{"CLADE$cladeInit"}{NODES}}){
    &printTree($toc,"",$c,\%TREE);
  }
  close OUT;
  close FNA;
  close TID;
  # read second time to fulfill
  my (%OFFS);
  open TMP,"cat $db/taxonomy/paths.txt $out/data/raw.txt|sort -r|";
  open TMP2,">$out/data/tmp.txt";
  my(%preBI,%represent);
  while(<TMP>){
    chomp;
    my @s = split /\t/;
    my @t = split /;/,$s[0];
    $s[3] ||= "PUB";
    $s[4] ||= 0;
    #
    if($t[-1] eq "species__Halorubrum sp. BI08"){
      my $debug = 1;
    }
    #
    if($t[-1] eq $OFFS{-1}{name}){
      if($s[4] > $represent{PBAmembers}){
        $represent{info} = [@s];
        $represent{PBAmembers} = $s[4];
      }
      $represent{sumPBAmembers} += $s[4];
    }elsif($represent{info}){
      my @is = @{$represent{info}};
      if($represent{sumPBAmembers} && $represent{sumPBAmembers} != $OFFS{$OFFS{-1}{i}}{offs}){
        #print STDERR "$s[3]\t$t[-1] diff. $represent{sumPBAmembers} != $OFFS{$OFFS{-1}{i}}{offs}\n";
      }
      $is[4] = $OFFS{$OFFS{-1}{i}}{offs}; #($represent{sumPBAmembers}>$OFFS{$OFFS{-1}{i}}{offs})?$represent{sumPBAmembers}:$OFFS{$OFFS{-1}{i}}{offs};
      $is[6] = ($is[6] eq "")?$preBI{$t[-1]}:$is[6];
      print TMP2 join("\t",@is)."\n";
      $preBI{$t[-2]} = $is[6];

      $represent{info} = [@s];
      $represent{PBAmembers} = $s[4];
      $represent{sumPBAmembers} = $s[4];
    }
    for(my $i=0;$i<@t;$i++){
      if($OFFS{$i}{name} ne $t[$i]){
        $OFFS{$i}{name} = $t[$i];
        $OFFS{$i}{offs} = 0;
      }
      if($s[2] eq "CLIP"){
        $OFFS{$i}{offs}++;
      }
    }
    $OFFS{-1}{name} = $t[-1];
    $OFFS{-1}{i} = $#t;
  }
  #print last one:
  my @is = @{$represent{info}};
  $is[4] = $OFFS{$OFFS{-1}{i}}{offs}; #($represent{sumPBAmembers}>$OFFS{$OFFS{-1}{i}}{offs})?$represent{sumPBAmembers}:$OFFS{$OFFS{-1}{i}}{offs};
  $is[6] = ($is[6] eq "")?$preBI{$OFFS{-1}{name}}:$is[6];
  print TMP2 join("\t",@is)."\n";
  #
  close TMP;
  close TMP2;
  `sort $out/data/tmp.txt >$out/data/added.txt`;
  &verbose("done\n");
  return();
}

sub getBID{
  my $i = shift;
  my $id = ($i =~ /^(.*BI\d+)_k\d+_(\d+)_.*C([0-9]+|-)_/)?"$1\.$2\.$3":$i;
  return($id);
}

sub getIDs{
  my $i = shift;
  my $cid = ($i =~ /^(.*BI\d+)_k\d+_(\d+)_.*C([0-9]+|-)_/)?"$1\.$2\.$3":$i;
  my $bid = ($i =~ /^(.*BI\d+)_k\d+_(\d+)_.*C([0-9]+|-)_/)?"$1":$i;
  return($cid,$bid);
}

sub printTree{
  my($TOC,$path,$clade,$T) = @_;
  unless($$T{$clade}{rankID}){
    $rankID ++;
    $$T{$clade}{rankID} = $rankID;
  }
  if($TOC eq "tax"){
    #if($$T{$clade}{UNDERPATH} && $path !~ /$$T{$clade}{cladeLv}/){
    if($$T{$clade}{UNDERPATH}){
      $path = $$T{$clade}{UNDERPATH};
    }else{
      $path = "$path$clade;";
    }
    #$path = ($$T{$clade}{UNDERPATH})?$$T{$clade}{UNDERPATH}:"$path$clade;";
  }else{
    $path .= "$clade;";
  }
  #assign default clade level for genus and species
  $clade =~ /(\S+)__(\d+)/;
  my $dCladeLv = $$T{$clade}{cladeLv}?$$T{$clade}{cladeLv}:$1;
  if($dCladeLv eq "CLADE$DEFAULT_GE" && $path!~/genus__/  ){ $dCladeLv = "genus"};
  if($dCladeLv eq "CLADE$DEFAULT_SP" && $path!~/species__/){ $dCladeLv = "species"};
  print OUT "$path\t$$T{$clade}{rankID}\t$dCladeLv\t$clade\t$$T{$clade}{PBAmembers}\t$$T{$clade}{UNDERTAX}\t$$T{$clade}{presentID}\n";
  foreach my $chs (sort keys %{$$T{$clade}{members}}){
    next unless $chs;
    next if exists $OCC{B}{$chs};
    $rankID ++;

    my $theRank = ($ANNO{$chs}{level})?$ANNO{$chs}{level}:"CLIP";
    #print OUT "$path$chs;\t$rankID\t$theRank\t$chs\t$ANNO{$chs}{tax}\t$ANNO{$chs}{A}\n";

    foreach my $s (sort keys %{$SEQ{$chs}}){
      print OUT "$path$s;\t$rankID\t$theRank\t$s\t1\t$ANNO{$s}{tax}\t$ANNO{$s}{A}\n";
      print TID "$s\t$rankID\n";
      print FNA ">$s\n$SEQ{$chs}{$s}\n";
    }
    $OCC{B}{$chs} ++;
  }
  foreach my $c (sort keys %{$$T{$clade}{children}}){
    next unless exists $$T{$c}{children} or exists $$T{$c}{members};
    #my $pathc = ($$T{$c}{UNDERTAX})?"$$T{$c}{UNDERPATH}":"$path$c;";
    &printTree($TOC,$path,$c,\%$T);
  }
}

##############################################################################
### mafft2tree: generate a path tree from vsearch uc file
##############################################################################
sub usage4mafft2tree{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 mafft2tree -a <annotation file> -d <db path> -s <ssu clusters prefix> -o <output>
    -i  beads sequence file (just read ID);
    -a  annotation file
    -d  kraken2 database location with custom preprared files:
          <db>/taxonomy/paths.txt
          <db>/seqid2taxid.map
          <db>/data/vsearch.allpair.txt
    -s  units clusters prefix
    -p  print path with taxname[tax] or clade name(default)[clade].
    -m  mode of cutoff for default genus and species clade. Default is [bac]
          bac: 0.97 for genus and 0.99 for species, according to SSU and LSU distribution.
          euk: 0.95 for genus and 0.97 for species, according to ITS distribution.
    -o  output db dir
    -v  verbose
    -h  show help info
USAGE
}
our($DEFAULT_GE,$DEFAULT_SP,%ANNO,%MAP,%DBTREE,%RANKI,%SEQ,$rankID,%OCC,%NEWICK,%DEFAULT_IDENTITY);
$rankID = 1;
sub run_mafft2tree{
  &usage4mafft2tree("generate a path tree from vsearch uc file") && exit unless @ARGV;
  my ($seq,$ann,$db,$toc,$tree,$ids,$lsu,$pmode,$out);
  GetOptions(
    "i=s" => \$seq,
    "a=s" => \$ann,
    "d=s" => \$db,
    "t=s" => \$tree,
    "p=s" => \$toc,
    "m=s" => \$pmode,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4mafft2tree("generate a path tree from vsearch uc file") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[mafft2tree] start\n  Initaiating ... ");
  my(%TREE,%CLADE,%CLADEINIT);
  $toc   ||= "clade";
  $pmode ||= "bac";
  ($DEFAULT_GE,$DEFAULT_SP) = ($pmode eq "bac")?(0.97,0.99):(0.95,0.97);
  &verbose("\n    Mode:$pmode. Using default cuoff of genus:$DEFAULT_GE and species:$DEFAULT_SP ... ");
  #$units ||= "ssu,its,lsu";
  $ids ||= "0.4,0.5,0.66,0.72,0.77,0.83,0.89,0.92,0.95,0.97,0.98,0.99,0.995,0.999,1";
  #&verbose("mode:$pmode | units:$units ... ");
  %DEFAULT_IDENTITY = ("domain",0.66,"major_clade",0.68,"kingdom",0.7,"phylum",0.76,
  "class",0.77,"order",0.83,"family",0.89,"genus",$DEFAULT_GE,"species",$DEFAULT_SP);
  if($out){
    system("mkdir -p $out/{data,library}");
    open OUT, ">$out/data/raw.txt" or die $!;
    #open FIN, "> $out/data/added.txt" or die $!;
    open TID, ">$out/data/added.acc_taxid" or die $!;
    open FNA, ">$out/library/added.fna" or die $!;
  }else{
    mkdir -p "./{data,library}";
    open OUT, "> data/raw.txt" or die $!;
    #open FIN, "> data/added.txt" or die $!;
    open TID, "> data/added.acc_taxid" or die $!;
    open FNA, "> library/added.fna" or die $!;

  }

  &verbose("done\n  Reading [bead] $seq ... ");
  open SEQ,"< $seq" or die $!;
  my $ori = $/; $/ = ">";
  while(<SEQ>){
    chomp; next unless $_;
    my @s = split /\n/;
    my $id = shift @s;
    $id = (split /\t|\s/,$id)[0];
    my $seq = join("\n",@s);
    my $CID = &getBID($id);
    $SEQ{$CID}{$CID} = $seq;
  }
  $/ = $ori;
  close SEQ;

  #my @units = split /,/,$units;
  my $cladeInit = 1;
  if($db){
    &verbose("done\n  Reading [db] seqid2taxid.map ... ");
    open MAP,"< $db/seqid2taxid.map" or die $!;
    while(<MAP>){
      chomp;
      my @s=split /\t/;
      $MAP{S}{$s[0]} = $s[1];
      $MAP{D}{$s[1]} = $s[0];
      #for BEAD+SUS: add pub seqs into tree
      $ANNO{$s[0]}{uniq} = "unique";
      $ANNO{$s[0]}{ID} = $s[0];
      $ANNO{$s[0]}{ident} = 1;
    }
    &verbose("done\n  Reading [db] taxonomy/paths.txt ... ");
    open TRE,"< $db/taxonomy/paths.txt" or die $!;
    while(<TRE>){
      chomp;
      my @s=split /\t/;
      my @t= split /;/,$s[0];
      $DBTREE{$s[1]}{path} = $s[0];
      $DBTREE{$s[1]}{name} = $t[-1];
      $DBTREE{$s[1]}{rank} = $s[-1];
      $DBTREE{index}{$t[-1]} = $s[1];
      $DBTREE{indexs}{$t[-1]}{$s[1]} = $t[-2];

      $t[-1] =~s/^(\S+)__//;
      $DBTREE{quickIndex}{$t[-1]} = ($DBTREE{quickIndex}{$t[-1]})?"":$s[1];
      $DBTREE{MAXID} = ($s[1] > $DBTREE{MAXID})? $s[1]:$DBTREE{MAXID};
      #$TREE{$s[1]}{names} = [@t];
    }
    close TRE;
    $rankID = $DBTREE{MAXID};
  }
  if($ann){
    &verbose("done\n  Reading [bead] $ann ... ");
    open ANN, "< $ann" or die $!;
    while(<ANN>){
      chomp;
      my @s = split "\t";
      my @b = split(/\|/, $s[0]);
      my $CID = &getBID($b[0]);
      next unless $s[19] eq "unique";
      my %TMP;
      $TMP{ssu} = ($s[17]=~/SSU\((\d+)\)/)?$1:0;
      $TMP{lsu} = ($s[17]=~/LSU\((\d+)\)/)?$1:0;
      $TMP{its} = ($s[17]=~/ITS\((\d+)\)/)?$1:0;
      my @ord = sort {$TMP{$b} <=> $TMP{$a}} keys %TMP;
      $ANNO{$CID}{U} = $ord[0];
      $ANNO{$CID}{A} = $_;
      $ANNO{$CID}{ID} = $s[18];
      $ANNO{$CID}{uniq} = $s[19];
      $ANNO{$CID}{tax} = $s[1];
      $ANNO{$CID}{ident} = $s[2];
      $ANNO{$CID}{level} = "CLIP";
    }
    close ANN;
  }
  &verbose("done\n  Reading newick files: ");
  open NEW, "<$tree" or die $!;
  my ($NodeNo,$currentNo) = (0,0);
  while(<NEW>){
    chomp;
    if($_ =~ /^\(+$/){
      # start of new nodes
      my @loops = split //, $_;
      foreach(@loops){
        $NodeNo ++;
        &newick_add($currentNo,$NodeNo);
        $currentNo = $NodeNo;
      }
    }elsif($_ =~ /^:/){
      # length of a tip, length of a node, and maybe start of new nodes
      my @attrs = split /,/, $_;

      # end nodes
      my @dists = split /\)/, $attrs[0];
      $NEWICK{$currentNo}{dist} = $dists[0];
      for(my $i=1;$i<@dists;$i++){
        &node_anno_determine($currentNo);
        $currentNo = $NEWICK{$currentNo}{parent};
        $NEWICK{$currentNo}{dist} = $dists[$i];
      }
      # start of new nodes
      my @loops = split //, $_;
      foreach(@loops){
        $NodeNo ++;
        &newick_add($currentNo,$NodeNo);
        $currentNo = $NodeNo;
      }
    }else{
      # a tip
      #19118_S2BI00202212_k41_1_flag=1_multi=10_3994_len=1796_C1__REV___1420_259-1419_-_
      $_ =~ /(\d+)_(.*BI\d+)_k\d+_(\d+)_.*C([-0-9])/;
      my ($order,$bid,$clipNo,$ctype) = ($1,$2,$3,$4);
      $NEWICK{$currentNo}{order} = $order;
      $NEWICK{$currentNo}{bid} = $bid;
      $NEWICK{$currentNo}{cid} = "$bid.$clipNo.$ctype";
      &bid_anno_counts($currentNo,$bid);

    }
  }
  #assign all members

  &verbose("done\n  Writing ... ");

  foreach my $c (sort keys %{$CLADE{"CLADE$cladeInit"}{NODES}}){
    &printTree($toc,"",$c,\%TREE);
  }
  close OUT;
  close FNA;
  close TID;
  # read second time to fulfill
  my (%OFFS);
  open TMP,"cat $db/taxonomy/paths.txt $out/data/raw.txt|sort -r|";
  open TMP2,">$out/data/tmp.txt";
  my(%preBI,%represent);
  while(<TMP>){
    chomp;
    my @s = split /\t/;
    my @t = split /;/,$s[0];
    $s[3] ||= "PUB";
    $s[4] ||= 0;
    #
    if($t[-1] eq "species__Halorubrum sp. BI08"){
      my $debug = 1;
    }
    #
    if($t[-1] eq $OFFS{-1}{name}){
      if($s[4] > $represent{PBAmembers}){
        $represent{info} = [@s];
        $represent{PBAmembers} = $s[4];
      }
      $represent{sumPBAmembers} += $s[4];
    }elsif($represent{info}){
      my @is = @{$represent{info}};
      if($represent{sumPBAmembers} && $represent{sumPBAmembers} != $OFFS{$OFFS{-1}{i}}{offs}){
        #print STDERR "$s[3]\t$t[-1] diff. $represent{sumPBAmembers} != $OFFS{$OFFS{-1}{i}}{offs}\n";
      }
      $is[4] = $OFFS{$OFFS{-1}{i}}{offs}; #($represent{sumPBAmembers}>$OFFS{$OFFS{-1}{i}}{offs})?$represent{sumPBAmembers}:$OFFS{$OFFS{-1}{i}}{offs};
      $is[6] = ($is[6] eq "")?$preBI{$t[-1]}:$is[6];
      print TMP2 join("\t",@is)."\n";
      $preBI{$t[-2]} = $is[6];

      $represent{info} = [@s];
      $represent{PBAmembers} = $s[4];
      $represent{sumPBAmembers} = $s[4];
    }
    for(my $i=0;$i<@t;$i++){
      if($OFFS{$i}{name} ne $t[$i]){
        $OFFS{$i}{name} = $t[$i];
        $OFFS{$i}{offs} = 0;
      }
      if($s[2] eq "CLIP"){
        $OFFS{$i}{offs}++;
      }
    }
    $OFFS{-1}{name} = $t[-1];
    $OFFS{-1}{i} = $#t;
  }
  #print last one:
  my @is = @{$represent{info}};
  $is[4] = $OFFS{$OFFS{-1}{i}}{offs}; #($represent{sumPBAmembers}>$OFFS{$OFFS{-1}{i}}{offs})?$represent{sumPBAmembers}:$OFFS{$OFFS{-1}{i}}{offs};
  $is[6] = ($is[6] eq "")?$preBI{$OFFS{-1}{name}}:$is[6];
  print TMP2 join("\t",@is)."\n";
  #
  close TMP;
  close TMP2;
  `sort $out/data/tmp.txt >$out/data/added.txt`;
  &verbose("done\n");
  return();
}

sub newick_add{
  my ($cno,$nno) = @_;
  $NEWICK{$cno}{kid} = $nno;
  $NEWICK{$nno}{mon} = $cno;
  $NEWICK{$nno}{anc} = [$cno,{$NEWICK{$cno}{anc}}];
}

sub bid_anno_counts{
  my ($cno,$bid) = shift;
  my $taxid = ($MAP{S}{$ANNO{$bid}{ID}})?$MAP{S}{$ANNO{$bid}{ID}}:$DBTREE{quickIndex}{$ANNO{$bid}{tax}};
  my @trees = split /;/,$DBTREE{$taxid}{path};
  my %PICKS;
  for(my $i=0;$i<@trees;$i++){
    my $t = $trees[$i];
    (my $r = $t) =~ s/__.*$//;
    next if $t =~ /[Uu]nknown|[Uu]nculture|sp\.$/;
    next if (keys %{$DBTREE{indexs}{$t}}) > 1; #skip if this tax name have multiple IDs.
    next unless $DEFAULT_IDENTITY{$r} &&
    $DEFAULT_IDENTITY{$r} *100 < $ANNO{$bid}{ident};
    $PICKS{$DEFAULT_IDENTITY{$r}} = $t;
  }
  #
  foreach my $n ({$NEWICK{$cno}{anc}}){
    $NEWICK{$n}{PBAs} ++;
    foreach my $r(sort keys %PICKS){
      $NEWICK{$n}{anno}{$r}{$PICKS{$r}} ++;
      $NEWICK{$n}{anno_count}{$r} ++;
    }
  }
  #
}

sub node_anno_determine{
  my ($cno) = shift;
  # determine child rank
  my ($maxRatio,$topTax,$topRank,$topRatio) = (0,"","",0);
  foreach my $r (sort {$b<=>$a} keys %{$NEWICK{$cno}{anno}}){
    foreach my $t (sort keys %{$NEWICK{$cno}{anno}{$r}}){
      my $pickRatio = $NEWICK{$cno}{anno}{$r}{$t}/$NEWICK{$cno}{anno_count};
      if($pickRatio >= 0.9 || $pickRatio > $maxRatio){
        $topTax  = $t;
        $topRank = $r;
        $topRatio= $pickRatio;
        last;
      }
      $maxRatio = ($pickRatio > $maxRatio)?$pickRatio:$maxRatio;
    }
  }
  my $underPath = $DBTREE{$DBTREE{index}{$topTax}}{path};
  my $rankID = $DBTREE{index}{$topTax};
}

##############################################################################
### tree2fa: get represent sequence of a specific rank level from a tree
##############################################################################
sub usage4tree2fa{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 tree2fa -i <fa> -r <rank> -d <clade> -t <db path> -o <output>
    -s  ssu fasta input file
    -l  lsu fasta input file
    -r  rank
    -d  clade if rank not available
    -c  config file to read taxID(the 1st column). -r and -d will be ignored.
    -t  db path tree
    -o  output file
    -p  check primer. Only SSU found FWD primer or LSU found REV primer retained.
    -a  Add annotation to seq id. May cause bug for phylotree generation.
    -v  verbose
    -h  show help info
USAGE
}
our(%ANNO,%MAP,%DBTREE,%RANKI,%SEQ,$rankID,%OCC);
$rankID = 1;
sub run_tree2fa{
  &usage4tree2fa("get represent sequence of a specific rank level from a tree") && exit unless @ARGV;
  my ($ssu,$lsu,$rank,$clade,$cfg,$treefile,$withAnno,$checkPrimer,$out);
  GetOptions(
    "s=s" => \$ssu,
    "l=s" => \$lsu,
    "r=s" => \$rank,
    "d=s" => \$clade,
    "c=s" => \$cfg,
    "t=s" => \$treefile,
    "a"   => \$withAnno,
    "p"   => \$checkPrimer,
    "o=s" => \$out,
    "v"   => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4tree2fa("get represent sequence of a specific rank level from a tree") && exit if $help;
  my (%SEQ,%PICK,%TREE,%CFG);
  open SSU, "< $ssu" or die $!;
  open LSU, "< $lsu" or die $!;
  open DBT, "< $treefile" or die $!;
  open CFG, "< $cfg" or die $! if $cfg;
  (my $outPfx = $out) =~ s/\.(fasta|fa|fna)$//;
  open OTBL, "> $outPfx.both.LSU.fa" or die $!;
  open OTBS, "> $outPfx.both.SSU.fa" or die $!;
  open OTS, "> $outPfx.SSU.fa" or die $!;
  open OTL, "> $outPfx.LSU.fa" or die $!;

  open IFB, "> $outPfx.both.inf" or die $!;
  open IFS, "> $outPfx.SSU.inf" or die $!;
  open IFL, "> $outPfx.LSU.inf" or die $!;
  &verbose("[tree2fa] start\n  Reading $cfg ... ");
  while(<CFG>){
    chomp;
    my @s = split /\t/;
    $CFG{$s[0]} = $s[1];
  }
  close CFG;
  &verbose("done\n  Reading $ssu ... ");
  my $ori = $/;
  $/ = ">";
  while(<SSU>){
    chomp;
    next unless $_;
    my @s = split /\n/;
    my $id = shift @s;
    my ($cid,$bid) = &getIDs($id);
    my ($nf,$nr) = &getPmr($id);
    my $seq = join("",@s);
    my $len = length($seq);
    $SEQ{"SSU"}{$cid}{seq} = $seq;
    $SEQ{"SSU"}{$cid}{len} = $len;
    $SEQ{"SSU"}{$cid}{pmr} = $nf;
    $SEQ{"SSU"}{$cid}{score} = $len + ($checkPrimer && $nf)?10000:0;
    $SEQ{LINK}{$bid}{SSU}{$cid} ++;
  }
  close SSU;
  &verbose("done\n  Reading $lsu ... ");
  while(<LSU>){
    chomp;
    next unless $_;
    my @s = split /\n/;
    my $id = shift @s;
    my ($cid,$bid) = &getIDs($id);
    my ($nf,$nr) = &getPmr($id);
    my $seq = join("",@s);
    my $len = length($seq);
    $SEQ{"LSU"}{$cid}{seq} = $seq;
    $SEQ{"LSU"}{$cid}{len} = $len;
    $SEQ{"LSU"}{$cid}{pmr} = $nr;
    $SEQ{"LSU"}{$cid}{score} = $len + ($checkPrimer && $nr)?10000:0;
    $SEQ{LINK}{$bid}{LSU}{$cid} ++;

  }
  close LSU;
  $/ = $ori;
  &verbose("done\n  Reading $treefile ... ");
  while(<DBT>){
    #DBT format: path|taxID|rank|clade|taxName|represent bead|anno
    chomp;
    my @s = split /\t/;
    my ($repID,$bid) = &getIDs($s[6]);
    $TREE{$s[3]} = ($s[5])?$s[5]:$s[3];
    my @path = split /;/,$s[0];
    my @alt = grep {keys %{$PICK{$_}} > 0} @path;
    if(@alt >1){
      my $debug =1 ;
    }
    die "Multiple picked clade found. Need check:".join(",",@alt)." at $.\n" if @alt > 1;
    if( ($CFG{$s[1]}) || ((not defined $cfg) && $s[2] eq $rank && $s[5]) ){
      my $findAlt = (@alt >0)?1:0;
      my $replace = ($findAlt && ($PICK{$alt[0]}{type} eq "clade" || $PICK{$alt[0]}{taxon} ne $s[5]) )?1:0;
      if($replace){
        delete $PICK{$alt[0]};
      }
      if($replace || $findAlt == 0){
        $PICK{$s[3]}{type} = "rank";
        $PICK{$s[3]}{rankID} = $s[1];
        $PICK{$s[3]}{taxon} = $TREE{$s[3]};
        $PICK{$s[3]}{path} = [@path];
        for my $u ("LSU","SSU"){
          if(exists $SEQ{$u}{$repID}{len}){
            if( $SEQ{$u}{$PICK{$s[3]}{$u}{ID}}{len} ){
              if($SEQ{$u}{$repID}{score} > $SEQ{$u}{$PICK{$s[3]}{$u}{ID}}{score}){
                $PICK{$s[3]}{$u}{ID} = $repID;
                $PICK{$s[3]}{path} = [@path]; # path of LSU will be overwriten by that of SSU if exists SSU path info
              }
            }else{
              $PICK{$s[3]}{$u}{ID} = $repID;
              $PICK{$s[3]}{path} = [@path];
            }
            $PICK{$s[3]}{BID}{$bid} ++;
          }
        }
      }
    }elsif( (not defined $cfg) && $s[2] =~ /$rank|$clade/){
      unless(@alt > 0 ){
        $PICK{$s[3]}{type} = "clade";
        $PICK{$s[3]}{rankID} = $s[1];
        $PICK{$s[3]}{taxon} = $s[3];
        $PICK{$s[3]}{path} = [@path];
        for my $u ("LSU","SSU"){
          if( exists $SEQ{$u}{$repID}{len} && (($checkPrimer && ($SEQ{$u}{$repID}{pmr} || $PICK{$s[3]}{type} eq "rank")) || not $checkPrimer) ){
            if( $SEQ{$u}{$PICK{$s[3]}{$u}{ID}}{len} ){
              if($SEQ{$u}{$repID}{score} > $SEQ{$u}{$PICK{$s[3]}{$u}{ID}}{score}){
                $PICK{$s[3]}{$u}{ID} = $repID;
                $PICK{$s[3]}{path} = [@path]; # LSU will be replaced by SSU if exists SSU path info
              }
            }else{
              $PICK{$s[3]}{$u}{ID} = $repID;
              $PICK{$s[3]}{path} = [@path];
            }
            $PICK{$s[3]}{BID}{$bid} ++;
          }
        }
      }
    }elsif(@alt > 0){
      for my $u ("LSU","SSU"){
        if(exists $SEQ{$u}{$repID}{len} && (($checkPrimer && ($SEQ{$u}{$repID}{pmr} || $PICK{$s[3]}{type} eq "rank")) || not $checkPrimer)){
          if($SEQ{$u}{$repID}{score} > $SEQ{$u}{$PICK{$alt[-1]}{$u}{ID}}{score}){
            $PICK{$alt[-1]}{$u}{ID} = $repID;
          }
          $PICK{$alt[-1]}{BID}{$bid} ++;
        }
      }
    }

  }
  close DBT;
  &verbose("done\n  Writing to $out ...");
  my (%TAX);
  my %COUNT = ("LSU",0,"SSU",0,"ALL",0,"MISS",0);
  foreach my $c (sort keys %PICK){

    my $taxon = $PICK{$c}{taxon};
    for my $u ("LSU","SSU"){
      if(exists $TAX{$taxon}{$u}{ID}){
        my $clade2rank = ($PICK{$c}{type} gt $TAX{$taxon}{type})?1:0;
        my $findLonger = ($PICK{$c}{type} eq $TAX{$taxon}{type} && $SEQ{$u}{$PICK{$c}{$u}{ID}}{score} > $SEQ{$u}{$TAX{$taxon}{$u}{ID}}{score})?1:0;
        if($clade2rank || $findLonger){
          $TAX{$taxon}{$u}{ID} = $PICK{$c}{$u}{ID};
          $TAX{$taxon}{path} = $PICK{$c}{path};
          $TAX{$taxon}{rankID} = $PICK{$c}{rankID};
          $TAX{$taxon}{type} = ($clade2rank)?$PICK{$c}{type}:$TAX{$taxon}{type};
        }
      }elsif(exists $PICK{$c}{$u}{ID}){
        $TAX{$taxon}{$u}{ID} = $PICK{$c}{$u}{ID};
        $TAX{$taxon}{path} = $PICK{$c}{path};
        $TAX{$taxon}{rankID} = $PICK{$c}{rankID};
        $TAX{$taxon}{type} = ($PICK{$c}{type} gt $TAX{$taxon}{type} )?$PICK{$c}{type}:$TAX{$taxon}{type};
      }else{
        #check if exist bead covered both SSU and LSU
        foreach my $b (sort keys %{$PICK{$c}{BID}}){
          foreach my $i (sort keys %{$SEQ{LINK}{$b}{$u}}){
            if(exists $SEQ{$u}{$TAX{$taxon}{$u}{ID}}{len}){
              if($SEQ{$u}{$i}{score} > $SEQ{$u}{$TAX{$taxon}{$u}{ID}}{score}){
                $TAX{$taxon}{$u}{ID} = $i;
              }
            }else{
              $TAX{$taxon}{$u}{ID} = $i;
              $TAX{$taxon}{$u}{type} = "sup";
            }
          }
        }
      }
      # keep clades for default phylum,genus and species
      # if($taxon=~/CLADE(0.72|0.97|0.99)/){
      #   $TAX{$taxon}{path} = $PICK{$c}{path};
      # }
    }
  }
  foreach my $c (sort keys %TAX){
    my ($tid,$cn,$cc,%FIND) = ($TAX{$c}{rankID},"","",());
    for my $u ("SSU","LSU"){
      if(exists $SEQ{$u}{$TAX{$c}{$u}{ID}}{len}){
        $FIND{$u} = 1;
        if ($TAX{$c}{$u}{type} eq "sup"){
          $FIND{"sup$u"} = 1;
        }elsif($TAX{$c}{type} eq "rank"){
          $FIND{"ann$u"} = 1;
        }elsif($TAX{$c}{type} eq "clade"){
          $FIND{"cld$u"} = 1;
        }
      }
    }
    my (@pn,@pc,$lastName,$lastClade);
    foreach my $p (@{$TAX{$c}{path}}){
      next if $TREE{$p} eq $lastName;
      push @pn, ($TREE{$p})?$TREE{$p}:$p;
      push @pc, $p;
      $lastName = $TREE{$p};
    }
    $cc = join(";",@pc);
    $cn = join(";",@pn);
    if($withAnno){
      #$cn =~ s/[)(:;,']//g;
      $cn =~ tr/ ()[]';/_<><>"\//;
    }

    if($FIND{SSU} == 1){
      print IFS "$tid\t$c\t$TAX{$c}{SSU}{ID}\t$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{len}\t$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{len}\t$cc\t$cn\n";
      if($withAnno){
        print OTS ">$cn\n$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq}\n";
      }else{
        print OTS ">$tid\n$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq}\n";
      }
      $COUNT{SSU} ++;
      $COUNT{supSSU} ++ if $FIND{supSSU} == 1;
      $COUNT{annSSU} ++ if $FIND{annSSU} == 1;
      $COUNT{cldSSU} ++ if $FIND{cldSSU} == 1;
    }
    if($FIND{LSU} == 1){
      print IFL "$tid\t$c\t$TAX{$c}{LSU}{ID}\t$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{len}\t$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{len}\t$cc\t$cn\n";
      if($withAnno){
        print OTL ">$cn\n$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq}\n";
      }else{
        print OTL ">$tid\n$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq}\n";
      }
      $COUNT{LSU} ++;
      $COUNT{supLSU} ++ if $FIND{supLSU} == 1;
      $COUNT{annLSU} ++ if $FIND{annLSU} == 1;
      $COUNT{cldLSU} ++ if $FIND{cldLSU} == 1;

    }
    if($FIND{SSU} + $FIND{LSU} == 2){
      my $str = join("\n",$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq},$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq});
      my $len = $SEQ{SSU}{$TAX{$c}{SSU}{ID}}{len} + $SEQ{LSU}{$TAX{$c}{LSU}{ID}}{len};
      print IFB "$tid\t$c\t$TAX{$c}{SSU}{ID}+$TAX{$c}{LSU}{ID}\t$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{len}\t$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{len}\t$cc\t$cn\n";
      if($withAnno){
        print OTBL ">$cn\n$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq}\n";
        print OTBS ">$cn\n$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq}\n";
      }else{
        print OTBL ">$tid\n$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq}\n";
        print OTBS ">$tid\n$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq}\n";
      }
      $COUNT{ALL} ++;
      $COUNT{valid} ++;
      $COUNT{supALL} ++ if $FIND{supSSU} + $FIND{supLSU} >= 1;
      if ($FIND{annSSU} + $FIND{annLSU} >= 1){
        $COUNT{annALL} ++;
      }else{
        $COUNT{cldALL} ++;
      }
    }elsif($FIND{SSU} + $FIND{LSU} == 1){
      $COUNT{valid} ++;
    }elsif($FIND{SSU} + $FIND{LSU} == 0){
      $COUNT{MISS} ++;
    }
  }

  close OUT;
  &verbose("done\n  Written ".($COUNT{valid}||0)." clade seqs. ".($COUNT{MISS}||0)." records cannot found seqs.\n");
  &verbose("  SSU: ".($COUNT{SSU}||0)." (".($COUNT{annSSU}||0)."+".($COUNT{cldSSU}||0)."+".($COUNT{supSSU}||0));
  &verbose(" | LSU: ".($COUNT{LSU}||0)."(".($COUNT{annLSU}||0)."+".($COUNT{cldLSU}||0));
  &verbose("+".($COUNT{supLSU}||0)." | BOTH:".($COUNT{ALL}||0)."(".($COUNT{annALL}||0)."+".($COUNT{cldALL}||0)."+".($COUNT{supALL}||0).")\n");
  &verbose("    * Each unit: <total number>(<from rank> + <from clade> + <from linkage clade>\n");
  return();
}

sub getPmr{
  my $i = shift;
  my ($f,$r) = (0,0);
  my @parts = $i =~ /(REV|FWD)/g;
  foreach my $p (@parts){
    if($p eq "FWD"){
      $f ++;
    }elsif($p eq "REV"){
      $r ++;
    }
  }
  return($f,$r);
}

##############################################################################
### observedOTUs: stat observed OTUs when sampling reads raise
##############################################################################
sub usage4observedOTUs{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 observedOTUs -i <root dir> -o output.tsv sam1 sam2 sam3 ... samN
    -i  root dir where all samples' dir locate.
    -d  specific database name to stat
    -r  specific repeat to stat
    -o  output filename
    ..  sample directory tags. read by provide order.
    -v  verbose
    -h  show help info
USAGE
}
sub run_observedOTUs{
  &usage4observedOTUs("stat observed OTUs when sampling reads raise") && exit unless @ARGV;
  my ($idir,$setdb,$setsize,$setrep,$db,$out);
  GetOptions(
    "i=s" => \$idir,
    "d=s" => \$setdb,
    "r=i" => \$setrep,
    "s=i" => \$setsize,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4observedOTUs("stat observed OTUs when sampling reads raise") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [observedOTUs] start ... \n  SAM: DB[REP][size] status:\n");
  open OUT,">$out" or die $!;
  my(%SAMIMAGE,%STAT);
  $setdb  ||= '*';
  $setsize||= '*';
  $setrep = '*' if $setrep eq "";
  while(@ARGV){
    my $sam = shift @ARGV;
    my @files = `ls $idir/$sam/KRAKEN/rand/$setdb\_$setsize.$setrep.bead.kreport2`;
    my %INFO = ();
    for(@files){
      $_ =~ /rand\/(\S+)_(\d+)\.(\d+)\.bead\.kreport2$/;
      $INFO{$1}{$3}{$2}{SAM} = $sam;
      $INFO{$1}{$3}{$2}{FILE} = $_;
    }
    my ($dbCount,$repCount,$maxSize) = (0,0,0);
    foreach my $db (sort keys %INFO){
      $dbCount ++;
      foreach my $rep (sort {$a<=>$b} keys %{$INFO{$db}}){
        $repCount ++;
        $SAMIMAGE{$db}{$rep}{T}{"psudoTaxForInit"} = 0;
        my @sizes = sort {$a<=>$b} keys %{$INFO{$db}{$rep}};
        foreach my $size (@sizes){
          &verbose("  $sam: $db\[$rep\]\[$size\] ...         \r");
          my %BASE = %{$SAMIMAGE{$db}{$rep}{T}};
          my ($count,$rBead,$tBead,$unclassified) = (0,0,0,0);
          open KK," < $INFO{$db}{$rep}{$size}{FILE}" or die $!;
          while(<KK>){
            my @s=split;
            if($s[3] eq "S"){
              $BASE{$s[4]} += $s[1];
              $rBead += $s[1];
            }elsif($s[3] eq "U"){
              $unclassified = $s[1];
            }
            $tBead += $s[2];
          }
          close KK;
          $count = grep {$BASE{$_} >= 10} %BASE;
          my $taxSize = keys %BASE;
          # stat
          my $cSize = $SAMIMAGE{$db}{$rep}{S} + $size;
          $STAT{$db}{$rep}{$cSize}{samSize} = $size;
          $STAT{$db}{$rep}{$cSize}{samName} = $sam;
          $STAT{$db}{$rep}{$cSize}{countOTUs} = $count;
          $STAT{$db}{$rep}{$cSize}{rankBeads} = $rBead + $SAMIMAGE{$db}{$rep}{R};
          $STAT{$db}{$rep}{$cSize}{totalBeads} = $tBead + $SAMIMAGE{$db}{$rep}{B};
          $STAT{$db}{$rep}{$cSize}{unclassified} = $unclassified + $SAMIMAGE{$db}{$rep}{U};
          $STAT{$db}{$rep}{$cSize}{taxsize} = $taxSize;
          # next size or save image of tax from the last size
          if($size == $sizes[-1]){
            $SAMIMAGE{$db}{$rep}{B} += $tBead;
            $SAMIMAGE{$db}{$rep}{R} += $rBead;
            $SAMIMAGE{$db}{$rep}{U} += $unclassified;
            $SAMIMAGE{$db}{$rep}{S}  = $cSize;
            %{$SAMIMAGE{$db}{$rep}{T}}  = %BASE;
            $maxSize = ($size > $maxSize)?$size:$maxSize;
          }
        }
        # next repeat
      }
      # next database
    }
    &verbose("  $sam: $dbCount dbs\[$repCount\]\[$maxSize\] pass\n");
    # next sample
  }
  &verbose("[log] pass reading! Now Writing ... ");
  foreach my $db (sort keys %STAT){
    foreach my $rep (sort {$a<=>$b} keys %{$STAT{$db}}){
      foreach my $cSize (sort {$a<=>$b} keys %{$STAT{$db}{$rep}}){
        print OUT join("\t",$db,$rep,$STAT{$db}{$rep}{$cSize}{samName},$STAT{$db}{$rep}{$cSize}{samSize},
        $cSize,$STAT{$db}{$rep}{$cSize}{countOTUs},$STAT{$db}{$rep}{$cSize}{totalBeads},
        $STAT{$db}{$rep}{$cSize}{rankBeads},$STAT{$db}{$rep}{$cSize}{unclassified},$STAT{$db}{$rep}{$cSize}{taxsize})."\n";
      }
    }
  }
  close OUT;
  &verbose("done!\n");
  return();
}

##############################################################################
### modKKreport: replace rank level for kraken report
##############################################################################
sub usage4modKKreport{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 modKKreport -m <ori:new> -r <change region> -i <kreport> [-o <new report>]
    -i  original kreport filename
    -o  modified kreport filename
    -r  change region. could be any key words. e.g. [Bacteria]
    -m  [original lv.:new lv.], e.g. [D1:P]
    -v  verbose
    -h  show help info
USAGE
}
sub run_modKKreport{
  &usage4modKKreport("replace rank level for kraken report") && exit unless @ARGV;
  my ($inf,$cmode,$region,$out);
  GetOptions(
    "i=s" => \$inf,
    "m=s" => \$cmode,
    "r:s" => \$region,
    "o:s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4modKKreport("replace rank level for kraken report") && exit if $help;
  &verbose("[log] Mode [modKKreport] start ... ");
  open OUT,($out)?">$out":"> -" or die $!;
  open INF,($inf)?"<$inf":"< - " or die $!;
  #recoganize change mode:
  $cmode =~ /^(\S+):(\S+)$/;
  my ($ori,$new) = ($1, $2);
  my $start = ($region)?0:1;
  my ($regionRank,$count);
  while(<INF>){
    my @s = split /\t/;
    if($region){
      if(( not $start ) && $s[5] =~ /$region/){
          $start = 1;
          $regionRank = $s[3];
      }elsif($regionRank eq $s[3]){
          $start = 0;
          $regionRank = "";
      }
    }
    #
    if ($start && $s[3] eq $ori){
        $s[3] = $new;
        $count ++;
    }
    print OUT join ("\t",@s);
  }
  close IN;
  close OUT;
  &verbose("$count replaced. done!\n");
  return();
}


















#FIN

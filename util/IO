#!/usr/bin/env perl
# (c) 2016 - 2019 Chao IN-HORSE SHARE ONLY
# ===================================================================
# Description:       functions to read files
# Author:            Chao | fangchao@genomics.cn
# Version:           v0.1
# Last modified:     03 Jan 2019 (since 03 Jan 2019)
# ===================================================================
# see detail below
use strict;
use Getopt::Long;
our($verbose,$help);
sub usage {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  IO <mode> [option]
  func:
    UCH    get seq from H records of a UC file
    maketree find cluster anno info and make a tree

options:  Defined according to the mode and cmd you chosed.
USAGE
}

&usage("Stating beads related information") && exit if @ARGV == 0 || $ARGV[0] eq "-h";

my $mode = shift @ARGV unless $ARGV[0] =~/^-/;

# Main start
&run_getUCH if $mode eq "uch";
&run_maketree if $mode eq "maketree";
&run_maketaxon if $mode eq "maketaxon";
&run_kk2prf if $mode eq "kk2prf";# Main end
&run_sumprf if $mode eq "sumprf";
&run_sumgff if $mode eq "sumgff";
&run_itsx if $mode eq "itsx";
&run_uc2fa if $mode eq "uc2fa";
&run_treeAnno if $mode eq "treeanno";
&run_printUniqSubunit if $mode eq "printUniqSubunit";
&run_printITSxSubunit if $mode eq "printITSxSubunit";
&run_makeClade if $mode eq "makeclade";
&run_clade2tree if $mode eq "clade2tree";
&run_tree2fa if $mode eq "tree2fa";
&run_observedOTUs if $mode eq "observedOTUs";
&verbose("[All done!]\n");

exit;

sub verbose{
  my $msg = shift;
  print STDERR $msg if $verbose;
}

##############################################################################
### UCH:  Get seq from H records of a UC file
##############################################################################
sub usage4uch {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 uch -i fasta -u clust.uc -o output.fa
    -a  bead annotation file (to remove potential hybridize bead)
    -i  fasta file
    -u  cluster file with 10 column
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_getUCH {
  &usage4uch("Output sequence ID that can be clustered.") && exit unless @ARGV;
  my ($cut,$ann,$inf,$ucf,$out);
  GetOptions(
    "c=f" => \$cut,
    "a=s" => \$ann,
    "i=s" => \$inf,
    "u=s" => \$ucf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4uch("Output sequence ID that can be clustered.") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  open ANN, "< $ann" or die $!;
  open UCF, "< $ucf" or die $!;
  open INF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
 my (%HYB,%ABG);
  while(<ANN>){
    chomp;
    my @s = split "\t";
    my @b = split(/\|/, $s[0]);
    if(@s == 27){
      $HYB{$b[0]} = 0;
      if($s[-7] eq "multi" && $s[-6] ne "sameSp."){
        $ABG{$b[0]} ++;
      }
    }elsif(@s == 30){
      if($s[-3] > 0){
        $HYB{$b[0]} ++;
      }
      if($s[19] eq "multi" && $s[20] ne "sameSp."){
        $ABG{$b[0]} ++;
      }
    }

  }
  close ANN;

  &verbose("[log] Mode [UCH] start ... \n");
  my(%CLUST,%TMP,%LOG);
  #Here is the shorts for each column. Find more detail in VSEARCH manual.
  ##   0         1       2            3            4  5  6      7     8        9##
  ##Type  #Cluster  length  similarity%  orientation  *  *  CIGAR query centroid##
  while(<UCF>){
    chomp;
    #next unless /^H/;
    my @s = split "\t";
    if($s[0] eq "S"){
      $TMP{$s[8]}{L} = $s[2];
    }elsif($s[0] eq "H"){
      my @b8 = split "_",$s[8];
      if($s[2] < $cut){
        $LOG{LEN} ++;
      }elsif(defined $HYB{$b8[0]}){
        $LOG{HYB} ++;
      }elsif(defined $ABG{$b8[0]}){
        $LOG{ABG} ++;
      }else{
        $LOG{USE} ++;
        $CLUST{$s[8]} ++;
      }
      next unless exists $TMP{$s[9]};
      if($TMP{$s[9]}{L} < $cut){
        $LOG{LEN} ++;
      }elsif(defined $HYB{$b8[0]}){
        $LOG{HYB} ++;
      }elsif(defined $ABG{$b8[0]}){
        $LOG{ABG} ++;
      }else{
        $LOG{USE} ++;
        $CLUST{$s[9]} ++;
      }
      delete $TMP{$s[9]};
    }

  }
  close UCF;
  $/=">";
  while(<INF>){
    chomp;
    my @s = split "\n";
    (my $id = $s[0]) =~/(\s|\t).*$/;
    if(exists $CLUST{$id}){
      print OUT ">".join("\n",@s)."\n";
    }
  }
  close INF;
  close OUT;

  &verbose("[log] Finish read&write.\n");
  &verbose("[log] Totally write $LOG{USE} sequences.\n");
  &verbose("[log] Discard $LOG{LEN} due to length < $cut\n") if $LOG{LEN} > 0;
  &verbose("[log] Discard $LOG{HYB} due to hybridization detected\n") if $LOG{HYB} > 0;
  &verbose("[log] Discard $LOG{ABG} due to ambiguous classific annotation detected\n") if $LOG{ABG} > 0;
}

##############################################################################
### maketree: find cluster anno info and make a tree
##############################################################################
sub usage4maketree {
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 uch -i fasta -u clust.uc -o output.fa
    -a  bead annotation file (to remove potential hybridize bead)
    -u  cluster file with 10 column
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_maketree {
  &usage4maketree("find cluster anno info and make a tree.") && exit unless @ARGV;
  my ($cut,$ann,$inf,$ucf,$out,$verbose,$help);
  GetOptions(
    "a=s" => \$ann,
    "u=s" => \$ucf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4maketree("Output sequence ID that can be clustered.") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  open ANN, "< $ann" or die $!;
  open UCF, "< $ucf" or die $!;
  #open INF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  my %ANNO;
  while(<ANN>){
    chomp;
    my @s = split "\t";
    my @b = split(/\|/, $s[0]);
    $ANNO{$b[0]} = $_;
  }
  close ANN;

  &verbose("[log] Mode [UCH] start ... \n");
  my(%CLUST);
  #Here is the shorts for each column. Find more detail in VSEARCH manual.
  ##   0         1       2            3            4  5  6      7     8        9##
  ##Type  #Cluster  length  similarity%  orientation  *  *  CIGAR query centroid##
  while(<UCF>){
    chomp;
    next unless /^C/;
    my @s = split "\t";
    my @b8 = split "_",$s[8];
    my $lotu = "LOTU_".($s[1]+1);

    print OUT "$lotu\t$ANNO{$b8[0]}\n";

  }
  close UCF;
  close OUT;
  &verbose("[log] Finish read&write.\n");
}

##############################################################################
### makeTaxon: find cluster anno info and make a tree
##############################################################################
sub usage4maketaxon{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 maketaxon -a annotation -u clust.uc -o output.fa
    -d  default domain [Bacteria]
    -a  bead annotation file (to remove potential hybridize bead)
    -u  cluster file with 10 column
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_maketaxon {
  &usage4maketaxon("find cluster anno info and make a tree.") && exit unless @ARGV;
  my ($dom,$ann,$tax,$ucf,$out,$verbose,$help);
  GetOptions(
    "d=s" => \$dom,
    "a=s" => \$ann,
    "u=s" => \$ucf,
    "t=s" => \$tax,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  $dom||="Bacteria";
  &usage4maketaxon("Output sequence ID that can be clustered.") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  open ANN, "< $ann" or die $!;
  open UCF, "< $ucf" or die $!;
  open TAX, "< $tax" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  open ACC, ($out)?">$out.acc_taxid":"> -" or die $!;
  my %ANNO;
  while(<ANN>){
    chomp;
    my @s = split "\t";
    my @b = split(/\|/, $s[0]);
    if($s[1]=~/^[^0-9]+/ && $s[2] =~ /^\d+/){
      $ANNO{$b[0]} = $s[1];
    }elsif($s[6]=~/^[^0-9]+/ && $s[7] =~ /^\d+/){
      $ANNO{$b[0]} = $s[6];
    }
  }
  close ANN;
  my %TAX;
  while(<TAX>){
    chomp;
    my @s = split "\t";
    my @b = split /;/, $s[0];
    my @n = split /__/,$b[-1];
    $TAX{I}{$s[1]}{L} = $s[2];
    $TAX{I}{$s[1]}{P} = $s[0];
    $TAX{I}{$s[1]}{N} = $n[1];
    $TAX{N}{$n[1]} = $s[1];
    $TAX{MAXID} = ($s[1] > $TAX{MAXID})? $s[1]:$TAX{MAXID};
  }
  close TAX;

  &verbose("[log] Mode [UCH] start ... \n");
  my(%CLUST);
  #Here is the shorts for each column. Find more detail in VSEARCH manual.
  ##   0         1       2            3            4  5  6      7     8        9##
  ##Type  #Cluster  length  similarity%  orientation  *  *  CIGAR query centroid##
  my $no = $TAX{MAXID};
  while(<UCF>){
    chomp;
    next unless /^C/;
    my @s = split "\t";
    my @b8 = split "_",$s[8];
    my $lotu = "LOTU_".($s[1]+1);
    my $lv = "LOTU";#($TAX{I}{$id}{L} eq "species")?"strain":"species";
    $no ++;
    if(exists $ANNO{$b8[0]}){
      if(exists $TAX{N}{$ANNO{$b8[0]}}){
        my $id = $TAX{N}{$ANNO{$b8[0]}};
        print OUT "$TAX{I}{$id}{P}$lotu;\t$no\t$lv\n"
      }else{
        my @pfx = split / /,$ANNO{$b8[0]};
        shift @pfx if $pfx[0] =~ /[Uu]nidentified|[Uu]ncultured|[Uu]nknown/;
        if(exists $TAX{N}{$pfx[0]}){
          my $id = $TAX{N}{$pfx[0]};
          print OUT "$TAX{I}{$id}{P}species__$ANNO{$b8[0]};\t$no\tspecies\n";
          $no ++;
          print OUT "$TAX{I}{$id}{P}species__$ANNO{$b8[0]};$lotu;\t$no\t$lv\n";
        }else{
          print OUT "domain__$dom;species__$ANNO{$b8[0]};\t$no\tspecies\n";
          $no ++;
          print OUT "domain__$dom;species__$ANNO{$b8[0]};$lotu;\t$no\t$lv\n";
        }
      }
    }else{
      print OUT "domain__$dom;$lotu;\t$no\t$lv\n";
    }
    print ACC "$lotu\t$no\n";

  }
  close UCF;
  close OUT;
  close ACC;
  &verbose("[log] Finish read&write.\n");
}


##############################################################################
### kk2prf: generate profile from kraken2
##############################################################################
sub usage4kk2prf{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 kk2prf -a annotation -u clust.uc -o output.fa
    -a  bead annotation file (to remove potential hybridize bead)
    -u  cluster file with 10 column
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
our(%NAMES);
sub run_kk2prf{
  &usage4kk2prf("generate profile from kraken2") && exit unless @ARGV;
  my ($db,$inf,$out);
  GetOptions(
    "d=s" => \$db,
    "i=s" => \$inf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4kk2prf("generate profile from kraken2") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [kk2prf] start ... \n");
  my $pfx = ($out=~/^(.*).prof$/)?$1:$out;
  open KK2, "< $inf" or die $!;
  open DBN, "< $db/taxonomy/names.dmp" or die $!;
  open DBD, "< $db/taxonomy/nodes.dmp" or die $!;
  open TAX, "< $db/taxonomy/paths.txt" or die $!;
  open OUT, ($out)?">$out":">/dev/null" or die $!;
  open OT0, ($out)?">$pfx.0000":">/dev/null" or die $!;
  open OTB, ($out)?">$pfx.bead":">-" or die $!;

  my (%KKX,%KKO,%TMP,$pID,$pHID,$tmpCount);
  &verbose("  Reading names.dmp ... ");
  while(<DBN>){
    chomp;
    my @s = split /\t+\|\t+/;
    $NAMES{$s[0]}{N} = $s[1];
  }
  close DBN;
  &verbose("done.\n  Reading nodes.dmp ... ");
  while(<DBD>){
    chomp;
    my @s = split /\t+\|\t+/;
    if($s[0] == 1) { $s[1] = 0 }
    foreach my $k (keys %{$NAMES{$s[1]}{A}}){ $NAMES{$s[0]}{A}{$k} ++;}
    $NAMES{$s[0]}{A}{$s[1]} ++;
    $NAMES{$s[0]}{P} = $s[1];
    $NAMES{$s[0]}{R} = $s[2];
  }
  close DBD;
  &verbose("done.\n  Reading kraken results ... \n");
  while(<KK2>){
    chomp;
    my @s = split /\t/;
    $s[1] =~ /(\d\d\d\d)_(\d\d\d\d_\d\d\d\d)$/;
    my ($BID,$HID) = ("$1\_$2",$1);
    if ($BID =~ /0000/){
      $KKO{$s[2]} ++;
    }else{
      if($BID ne $pID && $tmpCount > 0 ){
        my ($c1st,$c2nd,$dist,%BTMP) = &searchPath(\%TMP);
        my $pct = sprintf("%.2f",$BTMP{$c1st} / $tmpCount);
        print OTB "$tmpCount\t$pID\t$c1st\t$TMP{$c1st}\t$pct\t$c2nd\t$TMP{$c2nd}\t$dist\n";
        $KKX{$c1st} ++;
        #
        %TMP = ();
        $tmpCount = 0;
      }
      $TMP{$s[2]} ++;
      $pID = $BID;
      $tmpCount ++;
    }
    if($pHID ne $HID){
      &verbose("    processing [$BID] ... \r");
    }
    $pHID = $HID;
  }
  close KK2;
  close OTB;
  &verbose("\n  Reading kraken results ... done.\n  bead file written.\n  Reading paths.txt and outputing ... ");
  my %TAX;
  print OT0 sprintf("%8d\t%6d\t%s\t%s\t%s\n",$KKO{0},0,"root","UNCLASSIFIED","root");
  print OUT sprintf("%8d\t%6d\t%s\t%s\t%s\n",$KKX{0},0,"root","UNCLASSIFIED","root");
  while(<TAX>){
    chomp;
    my @s = split "\t";
    my @b = split /;/, $s[0];
    my @n = split /__/,$b[-1];
    if(exists $KKO{$s[1]}){
      print OT0 sprintf("%8d\t%6d\t%s\t%s\t%s\n",$KKO{$s[1]},$s[1],$s[2],$n[-1],$s[0]);
    }
    if(exists $KKX{$s[1]}){
      print OUT sprintf("%8d\t%6d\t%s\t%s\t%s\n",$KKX{$s[1]},$s[1],$s[2],$n[-1],$s[0]);
    }
  }
  close TAX;
  close OUT;
  close OT0;
  &verbose("done.\n  All done!\n");
  return();
}
###############################################################################
sub searchPath{
  my $T = shift @_;
  my %pickNodes;
  my @nodes = sort {$b<=>$a} keys %$T;
  my $n = shift @nodes;
  $pickNodes{$n} += $$T{$n};
  my @finds = ($n);
  foreach $n (@nodes){
    my ($catchFamily,$catches) = (0,0);
    foreach my $f (@finds){
      if(exists $NAMES{$f}{A}{$n}){
        $pickNodes{$f} += $$T{$n};
        $catches ++;
      }
    }
    if($catches == 0){
      push @finds, $n;
      $pickNodes{$n} += $$T{$n};
    }
  }
  @finds = sort {$pickNodes{$b}<=>$pickNodes{$a} or $b<=>$a } keys %pickNodes;
  my ($f1st,$f2nd,$dist) = ($finds[0],$finds[0],0);
  if(@finds > 1){
    $f2nd = $finds[1];
    my @parents1 =  sort {$b<=>$a} keys %{$NAMES{$f1st}{A}};
    my @parents2 =  sort {$b<=>$a} keys %{$NAMES{$f2nd}{A}};
    for(my $i=0;$i<@parents1;$i++){
      for(my $j=0;$j<@parents2;$j++){
        if($parents1[$i] eq $parents2[$j]){
          $dist = $i + $j + 2;
          last;
        }
      }
    }
  }
  return($f1st,$f2nd,$dist,%pickNodes);
}

##############################################################################
### sumprf: summarise kraken2 profile to specific rank
##############################################################################
sub usage4sumprf{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 sumprf -r [rank] -i <input.kraken2 profile> -o output.fa
    -r  rank. [domain|phylum|class|order|family|genus|species|LOTU]
    -i  kraken2 profile
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
our(%NAMES);
sub run_sumprf{
  &usage4kk2prf("summarise kraken2 profile to specific rank") && exit unless @ARGV;
  my ($rank,$name,$inf,$out);
  GetOptions(
    "r=s" => \$rank,
    "i=s" => \$inf,
    "n=s" => \$name,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4kk2prf("summarise kraken2 profile to specific rank") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [kk2prf] start ... \n");
  my $pfx = ($out=~/^(.*).prof$/)?$1:$out;
  open KK2, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  if($name){
    open NAME,"<$name" or die $!;
    while(<NAME>){
      chomp;
      my @s = split /[\s\t]*\|[\s\t]*/;
      $s[1] =~ /(\S+)\__(.*)/;
      $NAMES{$s[1]}{rank} = $1;
      $NAMES{$s[1]}{tax} = $2;
      $NAMES{$s[1]}{id} = $s[0];
    }
  }
  my (%KK,%GROUP,%TMP,%LAST,@prePath,$pHID,$tmpCount);
  &verbose("  Reading kraken2 profile ... ");
  while(<KK2>){
    chomp;
    my @s = split /\t/;
    if($s[3] eq "UNCLASSIFIED"){
      print OUT sprintf("%d\t%d\t%s\t%s\n",$s[0],0,"root",$s[3]);
      next;
    }
    my $curRank = $s[2];
    $LAST{$s[3]} = $curRank;
    my @curPath = split /;/,$s[4];
    my ($d,$r) = (-1,);
    for(my $i=0;$i<@curPath;$i++){
      if($curPath[$i] ne $prePath[$i]){$d=$i; last; }
    }
    for(my $i=0;$i<@curPath;$i++){
      if($curPath[$i] =~ /^(\S+)\_\_(.+)$/){
        if($1 eq $rank){$r=$i; last; }
      }else{
        if($LAST{$curPath[$i]} eq $rank){$r=$i;last}
      }
    }
    &sumRank($d,\%TMP,@prePath);
    &addRank(\@s,$d,$r,\%TMP,@curPath);
    @prePath = @curPath;
  }
  &sumRank(0,\%TMP,@prePath);
  close KK2;

  &verbose("done.\n  Writing ...");
  foreach my $tax (sort keys %{$TMP{count}}){
    if($TMP{count}{$tax} >0){
      print OUT sprintf("%d\t%d\t%s\t%s\n",$TMP{count}{$tax},$TMP{uniqID}{$tax},$TMP{rank}{$tax},$tax);
    }
  }
  return();
}

sub sumRank{
  my ($d,$T,@prePath) = @_;
  if($d >= 0){
    for(my $i=$#prePath;$i>=$d;$i--){
      my $parent = $prePath[$i];
      if(exists $$T{relation}{$prePath[$i]}{ChildMember}){
        foreach my $c (sort keys %{$$T{relation}{$prePath[$i]}{ChildMember}} ){
          $$T{count}{$c} += $$T{count}{$prePath[$i]} * ($$T{count}{$c}/$$T{relation}{$prePath[$i]}{ChildCount})
        }
        $$T{count}{$prePath[$i]} = 0;
      }
    }
  }
}
sub addRank{
  my ($c,$d,$r,$T,@curPath) = @_;
  my $e;
  if($r){
    $e = $r;
  }elsif($curPath[-1] =~ /^(\S+)\_\_(.+)$/){
    $e = $#curPath;
  }else{
    $e= $#curPath -1;
  }
  #my $e = ($r)?$r:$#curPath;
  for(my $i=0;$i<$e;$i++){
    $$T{relation}{$curPath[$i]}{ChildMember}{$curPath[$e]} ++;
    $$T{relation}{$curPath[$i]}{ChildCount} += $$c[0];
  }
  if($e < $#curPath && exists $NAMES{$curPath[$e]}){
    $$T{count}{$curPath[$e]} += $$c[0];
    $$T{rank}{$curPath[$e]} ||= $NAMES{$curPath[$e]}{rank};
    $$T{uniqID}{$curPath[$e]} ||= $NAMES{$curPath[$e]}{id};
  }else{
    $$T{count}{$curPath[$e]} += $$c[0];
    $$T{rank}{$curPath[$e]} ||= $$c[2];
    $$T{uniqID}{$curPath[$e]} ||= $$c[1];
  }
}

##############################################################################
### sumgff: summarise gff file from barrnap results
##############################################################################
sub usage4sumgff{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 sumgff -i <barrnap gff3> -o output.tsv
    -i  barrnap gff3 file
    -d  domain. [bac|euk]
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
our(%NAMES);
sub run_sumgff{
  &usage4sumgff("summarise gff file from barrnap results") && exit unless @ARGV;
  my ($rank,$dom,$inf,$out);
  GetOptions(
    "i=s" => \$inf,
    "d=s" => \$dom,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  $dom ||= "bac";
  my @units = ($dom =~ /[Bb]ac/)?("16S","23S","5S"):("18S","28S","5.8S");
  &usage4kk2prf("summarise gff file from barrnap results") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [sumgff] start ... \n");
  open GFF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  my %SCORE = ('16S'=>1,'18S'=>1,'5.8S'=>2,'5S'=>2,'23S'=>4,'28S'=>4);
  my (%BD,$pBI,$pCI);
  &verbose("  Reading gff ... ");
  while(<GFF>){
    chomp;
    next if /^#/;
    my @s = split /\t/;
    my @b = split /_/,$s[0];
    my ($uLen,$prod,$pct) = ($s[4] - $s[3], "NA", 0);
    if($pBI && $pBI ne $b[0]){
      print OUT "$pBI";
      my $score = 0;
      foreach my $u (@units){
        my ($l,$p) = (0,0);
        if($BD{$u}){
          ($l,$p) = ($BD{$u}{L},$BD{$u}{P});
          $score += $SCORE{$u}
        }
        print OUT "\t$l\t$p";
      }
      print OUT "\t$score\n";
      %BD = ();
    }
    if($s[8]=~/product=(\S+) ribosomal RNA/){
      $prod = $1; $pct = 100;
    }
    if($s[8]=~/note=aligned only (\d+) percent/){
      $pct = $1;
    }
    ($BD{$prod}{L},$BD{$prod}{P}) = ($pct > $BD{$b[0]}{$prod})?($uLen,$pct):($BD{$prod}{L},$BD{$prod}{P});

    ($pBI,$pCI) = ($b[0],$b[2]);
  }
  close GFF;
  close OUT;
  return();
}

##############################################################################
### itsx: summarise itsx position.txt info
##############################################################################
sub usage4itsx{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 itsx -i <barrnap gff3> -o output.tsv
    -i  itsx position file
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_itsx{
  &usage4itsx("summarise itsx position.txt info") && exit unless @ARGV;
  my ($rank,$inf,$out);
  GetOptions(
    "i=s" => \$inf,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4kk2prf("summarise itsx position.txt info") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [itsx] start ... \n");
  open ITS, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  my %SCORE = ("SSU"=>1,"ITS1-2"=>2,'LSU'=>4);
  my %SCOREITS = ("ITS1"=>1,'5.8S'=>2,"ITS2"=>4);
  my %BD = ("SSU"=>0,"ITS1"=>0,'5.8S'=>0,"ITS2"=>0,'LSU'=>0);
  my ($score,$scoreits,$pBI,$pCI) = (0, 0, , );
  &verbose("  Reading ITSx position.txt ... ");
  while(<ITS>){
    chomp;
    next if /^#|Chimeric/;
    my @s = split /\t/;
    my @b = split /_/,$s[0];
    $s[1] =~ s/ bp.//;
    if($pBI && $pBI ne $b[0]){
      print OUT "$pBI";
      foreach my $u ("SSU","ITS1","5.8S","ITS2","LSU"){
        print OUT "\t$BD{$u}";
      }
      print OUT "\t$score\t$scoreits\n";
      %BD = ("SSU"=>0,"ITS1"=>0,'5.8S'=>0,"ITS2"=>0,'LSU'=>0);
      ($score,$scoreits)=(0,0)
    }
    for(my $i=2;$i<7;$i++){
      if($s[$i] =~/(\S+): (\d+)-(\d+)/){
        my ($unit,$ulen) = ($1, $3 - $2 + 1);
        my $unit1 = ($unit=~/ITS|5.8S/)?"ITS1-2":$unit;
        if($BD{$unit} == 0){
          unless($unit=~/ITS|5.8S/ && $BD{"ITS1"} + $BD{"5.8S"} + $BD{"ITS2"} > 0){
             $score += $SCORE{$unit1}
           }
           $scoreits += $SCOREITS{$unit} if exists $SCOREITS{$unit};
           $BD{$unit} = $ulen;
        }else{
          $BD{$unit} = $ulen if $ulen > $BD{$unit};
        }
      }elsif($s[$i] =~/(\S+): No end/){
        my ($unit,$ulen,$start,$end) = ($1,0,0,$s[1]);
        my $unit1 = ($unit=~/ITS|5.8S/)?"ITS1-2":$unit;
        if($s[$i-1] =~/(\S+): (\d+)-(\d+)/){
          $start = $3 + 1;
        }
        if($s[$i+1] =~/(\S+): (\d+)-(\d+)/){
          $end = $2 - 1;
        }
        $ulen = $end - $start + 1;
        if($BD{$unit} == 0){
          $score += $SCORE{$unit1} if $BD{"ITS1"} + $BD{"5.8S"} + $BD{"ITS2"} == 0;
          $scoreits += $SCOREITS{$unit} if exists $SCOREITS{$unit};
          $BD{$unit} = $ulen;
        }else{
          $BD{$unit} = $ulen if $ulen > $BD{$unit};
        }
      }
    }
    ($pBI,$pCI) = ($b[0],$b[2]);
  }
  close ITS;
  close OUT;
  return();
}


##############################################################################
### uc2fa: get forward strand of barrnaped sequence from vsearch cluster file
##############################################################################
sub usage4uc2fa{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 uc2fa -i <fa file>  -u <uc file> -o output.fa
    -i  fa file
    -u  uc file
    -m  minimum length allowed
    -t  tag/label, default "OTU_"
    -a  anno file to change ID
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_uc2fa{
  &usage4uc2fa("get forward strand of barrnaped sequence from vsearch cluster file") && exit unless @ARGV;
  my ($rank,$inf,$anno,$inu,$tag,$min,$out);
  GetOptions(
    "i=s" => \$inf,
    "u=s" => \$inu,
    "m=f" => \$min,
    "a:s" => \$anno,
    "t=s" => \$tag,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4uc2fa("get forward strand of barrnaped sequence from vsearch cluster file") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[uc2fa] Mode start\n");
  my (%CLUST,%SEQ,%MAP);
  open INU, "< $inu" or die $!;
  open INF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  if($anno){
    &verbose("  Reading $anno ... ");
    open ANN,"< $anno" or die $!;
    while(<ANN>){
      chomp;
      my @s = split /\t/;
      $s[0] =~ /^(\S+_k\d+_\d+)/;
      $MAP{$1} = $s[-3];
    }
    &verbose("done\n")
  }
  &verbose("  Reading $inu ... ");
  while(<INU>){
    chomp;
    my @s = split /\t/;
    next unless $s[0] eq "S" && $s[2] >= $min;
    die "cannot recoganize id string!\n" unless @s[8] =~ /^(\S+_k\d+_\d+)_.+\(([+-])\)/;
    my ($BID,$strand) = ($1,$2);
    $CLUST{$s[8]}{BID} = $BID;
    $CLUST{$s[8]}{STR} = $strand;
    $CLUST{$s[8]}{ORD} = $s[1] + 1;
  }
  close INU;
  &verbose("done\n  Reading $inf ... ");
  $/=">";
  while(<INF>){
    chomp;
    next unless $_;
    my @s = split /\n/;
    my $id = shift @s;
    my $seq = join("",@s);
    next unless exists $CLUST{$id};
    $SEQ{$CLUST{$id}{ORD}}{ID} = (exists $MAP{$CLUST{$id}{BID}})?$MAP{$CLUST{$id}{BID}}:$tag.$CLUST{$id}{ORD};
    $SEQ{$CLUST{$id}{ORD}}{SEQ} = ($CLUST{$id}{STR} eq "+")?$seq:&xDNA("rc",$seq);
  }
  close INF;
  &verbose("done\n  writing ... ");
  foreach my $no (sort {$a<=>$b} keys %SEQ){
    print OUT ">$SEQ{$no}{ID}\n$SEQ{$no}{SEQ}\n";
  }
  close OUT;
  &verbose("done\n");
  return();
}

sub xDNA{
  my ($mod,$str) = @_;
  my %SH;
  for(my $p=0;$p<length($str);$p++){
    my $pick = substr($str,$p,1);
    my $comp = ($pick eq "A")?"T":(($pick eq "T")?"A":(($pick eq "G")?"C":(($pick eq "C")?"G":$pick)));
    $SH{$p}{'raw'} = $pick;
    $SH{$p}{'com'} = $comp;
  }
  my $res = "";
  if($mod =~ /r/){
    foreach my $p (sort {$b<=>$a} %SH){
      $res .= ($mod =~/c/)?$SH{$p}{'com'}:$SH{$p}{'raw'};
    }
  }else{
    foreach my $p (sort {$a<=>$b} %SH){
      $res .= ($mod =~/c/)?$SH{$p}{'com'}:$SH{$p}{'raw'};
    }
  }
  return($res);
}


##############################################################################
### treeAnno: find and replace with annotation of tree nodes id
##############################################################################
sub usage4treeAnno{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 treeanno -t <tree> -a <anno file> -u <uc file> -o <new tree>
    -i  fa file
    -u  uc file
    -m  minimum length allowed
    -t  tag/label, default "OTU_"
    -a  anno file to change ID
    -o  output filename
    -v  verbose
    -h  show help info
USAGE
}
sub run_treeAnno{
  &usage4treeAnno("find and replace with annotation of tree nodes id") && exit unless @ARGV;
  my ($rank,$inf,$anno,$inu,$tag,$min,$out);
  GetOptions(
    "i=s" => \$inf,
    "u=s" => \$inu,
    "m=f" => \$min,
    "a:s" => \$anno,
    "t=s" => \$tag,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4treeAnno("find and replace with annotation of tree nodes id") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[treeAnno] Mode start\n");
  my (%CLUST,%SEQ,%MAP);
  $tag ||= "OTU_";
  open INU, "< $inu" or die $!;
  open INF, "< $inf" or die $!;
  open OUT, ($out)?">$out":">-" or die $!;
  open ANN,"< $anno" or die $!;
  &verbose("  Reading $anno ... ");
  while(<ANN>){
    chomp;
    my @s = split /\t/;
    $s[0] =~ /^(\S+_k\d+_\d+)/;
    $MAP{$1} = $s[-3];
  }
  &verbose("done\n  Reading $inu ... ");
  while(<INU>){
    chomp;
    my @s = split /\t/;
    next unless $s[0] eq "S" && $s[2] >= $min;
    die "cannot recoganize id string!\n" unless @s[8] =~ /^(\S+_k\d+_\d+)_.+\(([+-])\)/;
    my ($BID,$strand) = ($1,$2);
    $CLUST{$s[1]+1} = $BID;
  }
  close INU;
  &verbose("done\n  Reading $inf ... ");
  $/=$tag;
  while(<INF>){
    chomp;
    $_ =~ s/^(\d+)//;
    my $otu = $1;
    if( exists $MAP{$CLUST{$otu}}){
      print OUT $MAP{$CLUST{$otu}}.$_;
    }else{
      print OUT $otu.$_.$tag;
    }
  }
  close INF;
  close OUT;
  &verbose("done\n");
  return();
}

##############################################################################
### printUniqSubunit: print bead's subunits seqs
##############################################################################
sub run_printUniqSubunit{
  my ($inf,$tag,$out);
  GetOptions(
    "i=s" => \$inf,
    "t=s" => \$tag,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  #&usage("[fatal] Essential input is missing");
  &verbose("[printUniqSubunit] start\n");
  open INF, "< $inf" or die $!;
  open OUT, "> $out" or die $!;
  &verbose("  Reading $inf ... ");
  my $ori = $/; $/ = ">";
  my (%SEQ,@ORDER);
  while(<INF>){
    next unless $_ =~/$tag/;
    chomp;
    my @s = split /\n/;
    my $sid = shift @s;
    my $seq = join("\n",@s);
    my $len = length($seq);
    next unless $len > 999;
    $sid =~ s/^.*:://;
    #$sid =~/^(.*BI\d+)_k\d+_(\d+)_.*_(C[0-9\-])_/;
    #$SEQ{"$1.$2.$3"}{$sid} = $seq;
    #push @ORDER, "$1.$2.$3";
    print OUT ">$sid\n$seq\n";
  }
  close INF;
  # &verbose("Done\n  writing ... ");
  # while(@ORDER){
  #   my $b = shift @ORDER;
  #   #my @c = keys %{$SEQ{$b}};
  #   #next if scalar @c > 1;
  #   foreach my $c (sort keys %{$SEQ{$b}}){
  #     print OUT ">$c\n$SEQ{$b}{$c}\n";
  #   }
  # }
  close OUT;
  &verbose("DONE!\n");
}
##############################################################################
### extractITSxSubunits: print each subunits from ITSx prediction (for euk)
##############################################################################
sub run_printITSxSubunit{
  my ($inf,$pos,$out);
  GetOptions(
    "i=s" => \$inf,
    "p=s" => \$pos,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  #&usage("[fatal] Essential input is missing");
  &verbose("[printITSxSubunit] start\n");
  open INF, "< $inf" or die $!;
  open POS, "< $pos" or die $!;
  open SSU, "> $out.SSU.fasta" or die $!;
  open LSU, "> $out.LSU.fasta" or die $!;
  &verbose("  Reading $pos ... ");
  my (%POS,%SEQ,@ORDER);
  while(<POS>){
    next if $_ =~ /Chimeric/;
    chomp;
    my @s = split /\t/;
    my $id = shift @s;
    my $slen = shift @s;
    next if $slen < 1000;
    while(@s){
      my $str = shift @s;
      if($str =~ /(\S+): (\d+)-(\d+)/ ){
        my ($unit,$offset,$len) = ($1,$2-1,$3-$2+1);
        $POS{$id}{$unit}{O} = $offset;
        $POS{$id}{$unit}{L} = $len;
      }
    }
  }
  close POS;
  &verbose("done!\n  Reading $inf ... ");
  my $ori = $/; $/ = ">";
  while(<INF>){
    chomp;
    my @s = split /\n/;
    my $sid = shift @s;
    next unless exists $POS{$sid};
    my $seq = join("\n",@s);
    my $len = length($seq);
    #SSU
    if($POS{$sid}{"SSU"}{L} > 999){
      my $ssu = substr($seq,$POS{$sid}{"SSU"}{O},$POS{$sid}{"SSU"}{L});
      print SSU ">$sid\n$ssu\n";
    }
    #LSU
    if($POS{$sid}{"LSU"}{L} > 999){
      my $lsu = substr($seq,$POS{$sid}{"LSU"}{O},$POS{$sid}{"LSU"}{L});
      print LSU ">$sid\n$lsu\n";
    }
  }
  close INF;
  close SSU;
  close LSU;
  &verbose("DONE!\n");
}
##############################################################################
### makeClade: cluster SSU/LSU into clades with specific identity of similairty
##############################################################################
sub usage4makeClade{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 makeClade -t <tree> -d <identities> -o <output prefix>
    -i  fa file
    -d  identities. [0.9,0.95,0.97,0.99,0.995]
    -t  threads. default [1]
    -o  output prefix
    -v  verbose
    -h  show help info
USAGE
}
our(%UC);
sub run_makeClade{
  &usage4makeClade("cluster SSU/LSU into clades with specific identity of similairty") && exit unless @ARGV;
  my ($inf,$ids,$cpu,$ann,$out);
  GetOptions(
    "i=s" => \$inf,
    "d=s" => \$ids,
    "t:f" => \$cpu,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4makeClade("cluster SSU/LSU into clades with specific identity of similairty") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[makeClade] Mode start\n");
  my (%SEQ);
  $ids ||= "0.4,0.5,0.66,0.72,0.77,0.83,0.89,0.92,0.95,0.97,0.98,0.99,0.995,0.999,1";
  $cpu ||= 1;
  my @ids = split /,/,$ids;
  open INF, "< $inf" or die $!;
  &verbose("  Reading $inf ... ");
  my $ori = $/; $/ = ">";
  while(<INF>){
    chomp; next unless $_;
    my @s = split /\n/;
    my $sid = shift @s;
    my $seq = join("\n",@s);
    $SEQ{$sid} = $seq;
  }
  close INF;
  &verbose("DONE!\n");

  $/=$ori;
  chomp(my $ramtmp=("-e /dev/shm")?`mktemp -d /dev/shm/otupair.XXXXXXXXXX`:"mktemp -dp $out.XXX");
  my $pid = 0;
  while(@ids){
    my $id = pop @ids;
    my $inputfile = "";
    open OUT, ($out)?">$out\_$id":">-" or die $!;
    if($pid !=0){
      my $counts = scalar (keys %{$UC{$pid}});
      my $count = 0;
      open TMP, ">$ramtmp/tmp.fa" or die $!;
      foreach my $c (sort {$a<=>$b} keys %{$UC{$pid}}){
        #next if $UC{$pid}{$c}{N} < 2;
        $count ++;
        print TMP ">$c\n$SEQ{$c}\n";
        # foreach my $m (sort keys %{$UC{$pid}{$c}{M}}){
        #   $count ++;
        #   print TMP ">$m\n$SEQ{$m}\n";
        # }
      }
      close TMP;
      $inputfile = "$ramtmp/tmp.fa";
    }else{
      $inputfile = $inf;
    }
    #$inputfile = $inf;
    my $cmd = "vsearch --threads $cpu --cluster_fast $inputfile --iddef 0 --id $id --uc - ";
    &verbose("  Clustering at $id [$cmd] \n");
    &readUC($id,$cmd);
    $pid = $id;
  }
  return();
}

sub readUC{
  my ($id,$cmd) = @_;
  open UC,"$cmd|" or die $!;
  while(<UC>){
    print OUT $_;
    chomp;
    my @u = split /\t/;
    #next unless $u[0] eq "H";
    if($u[0] eq "S"){
      $UC{$id}{$u[8]}{L} = $u[2];
    }elsif($u[0] eq "H"){
      $UC{$id}{$u[9]}{M}{$u[8]}{I} = $u[3];
      $UC{$id}{$u[9]}{M}{$u[8]}{L} = $u[2];
    }elsif($u[0] eq "C"){
      $UC{$id}{$u[8]}{N} = $u[2];
    }
  }
  close UC;
}


##############################################################################
### clade2tree: generate a path tree from vsearch uc file
##############################################################################
sub usage4clade2tree{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 clade2tree -a <annotation file> -d <db path> -s <ssu clusters prefix> -o <output>
    -i  beads sequence file (just read ID);
    -a  annotation file
    -d  kraken2 database location with custom preprared files:
          <db>/taxonomy/paths.txt
          <db>/seqid2taxid.map
          <db>/data/vsearch.allpair.txt
    -s  units clusters prefix
    -u  units to combine [ssu,its,lsu]
    -m  mode of cutoff for default genus and species clade. Default is [bac]
          bac: 0.99 for genus and 0.995 for species, according to SSU and LSU distribution.
          euk: 0.95 for genus and 0.97 for species, according to ITS distribution.
    -o  output db dir
    -v  verbose
    -h  show help info
USAGE
}
our(%ANNO,%MAP,%DBTREE,%RANKI,%SEQ,$rankID,%OCC);
$rankID = 1;
sub run_clade2tree{
  &usage4clade2tree("generate a path tree from vsearch uc file") && exit unless @ARGV;
  my ($seq,$ann,$db,$units,$upfx,$ids,$lsu,$pmode,$out);
  GetOptions(
    "i=s" => \$seq,
    "a=s" => \$ann,
    "d=s" => \$db,
    "s=s" => \$upfx,
    "u=s" => \$units,
    "m=s" => \$pmode,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4clade2tree("generate a path tree from vsearch uc file") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[clade2tree] start\n  Initaiating ... ");
  my(%TREE,%CLADE,%CLADEINIT);
  $pmode ||= "bac";
  $units ||= "ssu,its,lsu";
  $ids ||= "0.4,0.5,0.66,0.72,0.77,0.83,0.89,0.92,0.95,0.97,0.98,0.99,0.995,0.999,1";
  &verbose("mode:$pmode | units:$units ... ");
  my %DEFAULT_IDENTITY = ("domain",0.66,"major_clade",0.68,"kingdom",0.7,"phylum",0.76,"class",0.77,"order",0.83,"family",0.89,"genus",0.97,"species",0.99);
  if($out){
    system("mkdir -p $out/{data,library}");
    open OUT, ">$out/data/added.txt" or die $!;
    open TID, ">$out/data/added.acc_taxid" or die $!;
    open FNA, ">$out/library/added.fna" or die $!;
  }else{
    mkdir -p "./{data,library}";
    open OUT, "> data/added.txt" or die $!;
    open TID, "> data/added.acc_taxid" or die $!;
    open FNA, "> library/added.fna" or die $!;

  }

  &verbose("done\n  Reading [com] $seq ... ");
  open SEQ,"< $seq" or die $!;
  my $ori = $/; $/ = ">";
  while(<SEQ>){
    chomp; next unless $_;
    my @s = split /\n/;
    my $id = shift @s;
    my $seq = join("\n",@s);
    my $CID = &getBID($id);
    $SEQ{$CID}{$CID} = $seq;
  }
  $/ = $ori;
  close SEQ;

  my @units = split /,/,$units;
  my $cladeInit = 1;
  if($db){
    &verbose("done\n  Reading [com] seqid2taxid.map ... ");
    open MAP,"< $db/seqid2taxid.map" or die $!;
    while(<MAP>){
      chomp;
      my @s=split /\t/;
      $MAP{S}{$s[0]} = $s[1];
      $MAP{D}{$s[1]} = $s[0];
      #for BEAD+SUS: add pub seqs into tree
      $ANNO{$s[0]}{uniq} = "unique";
      $ANNO{$s[0]}{ID} = $s[0];
      $ANNO{$s[0]}{ident} = 1;
    }
    &verbose("done\n  Reading [com] taxonomy/paths.txt ... ");
    open TRE,"< $db/taxonomy/paths.txt" or die $!;
    while(<TRE>){
      chomp;
      my @s=split /\t/;
      my @t= split /;/,$s[0];
      $DBTREE{$s[1]}{path} = $s[0];
      $DBTREE{$s[1]}{name} = $t[-1];
      $DBTREE{$s[1]}{rank} = $s[-1];
      $DBTREE{index}{$t[-1]} = $s[1];
      $t[-1] =~s/^(\S+)__//;
      $DBTREE{quickIndex}{$t[-1]} = ($DBTREE{quickIndex}{$t[-1]})?"":$s[1];
      $DBTREE{MAXID} = ($s[1] > $DBTREE{MAXID})? $s[1]:$DBTREE{MAXID};
      #$TREE{$s[1]}{names} = [@t];
    }
    close TRE;
    $rankID = $DBTREE{MAXID};

    foreach my $unit (@units){
      #&verbose("done\n  Reading [$unit] data/$unit.allpair.txt ... ");
      #open IDE,"<$db/data/$unit.allpair.txt" or die $!;
      #while(<IDE>){
      #  chomp;
      #  my @s = split /\t/;
      #  my @q = split /,/,$s[4];
      #  $RANKI{$unit}{$s[1]}{Lv} = $s[0];
      #  $RANKI{$unit}{$s[1]}{quants} = [@q];
      #}
      #close IDE;
    }
  }
  if($ann){
    &verbose("done\n  Reading [com] $ann ... ");
    open ANN, "< $ann" or die $!;
    while(<ANN>){
      chomp;
      my @s = split "\t";
      my @b = split(/\|/, $s[0]);
      my $CID = &getBID($b[0]);
      next unless $s[19] eq "unique";
      my %TMP;
      $TMP{ssu} = ($s[17]=~/SSU\((\d+)\)/)?$1:0;
      $TMP{lsu} = ($s[17]=~/LSU\((\d+)\)/)?$1:0;
      $TMP{its} = ($s[17]=~/ITS\((\d+)\)/)?$1:0;
      my @ord = sort {$TMP{$b} <=> $TMP{$a}} keys %TMP;
      $ANNO{$CID}{U} = $ord[0];
      $ANNO{$CID}{A} = $_;
      $ANNO{$CID}{ID} = $s[18];
      $ANNO{$CID}{uniq} = $s[19];
      $ANNO{$CID}{tax} = $s[1];
      $ANNO{$CID}{ident} = $s[2];
      if($CID eq "O5BI00017539.1.1"){
        my $debug = 1;
      }
      #determine similairty of this annotation
      #if($RANKI{$ord[0]}{$s[1]}{quants}[4] && $RANKI{$ord[0]}{$s[1]}{quants}[4] < $s[2]){
      #  $ANNO{$CID}{level} = "species";
      #}else{
        $ANNO{$CID}{level} = "CLIP";
      #}
    }
    close ANN;
  }
  &verbose("done\n  Reading UC files: ");
  my @ids = split /,/,$ids;
  $cladeInit = ($cladeInit<$ids[0])?$cladeInit:$ids[0];
  my ($pCladeLv,$cladeNo0)=("",0);
  my $lastID = 0;
  while(@ids){
    my $id = pop @ids;
    my $nextID = ($ids[-1])?$ids[-1]:0;
    open SUC, "<$upfx\_$id" or next;
    my $cladeLv = "CLADE$id";
    my $cladeLvLast = "CLADE$lastID";
    my $cladeLvNext = (@ids)?"CLADE$ids[0]":"CLADEFINAL";
    my $cladeNo = 0;
    &verbose("$id ");
    while(<SUC>){
      chomp;
      #next unless $_ =~ /^H/;
      my @s = split /\t/;
      if($s[0] eq "S"){
        my $BID = &getBID($s[8]);

        $cladeNo ++;
        $CLADE{$cladeLv}{$BID}{No} = $cladeNo;
        my $cladeName = $cladeLv."__".$CLADE{$cladeLv}{$BID}{No};
        #assign for current level
        $TREE{$cladeName}{cladeLv} = $cladeLv;
        # check whether this clade has a child clade
        if(exists $CLADE{$cladeLvLast}{$BID}){
          my $cladeChild = $cladeLvLast."__".$CLADE{$cladeLvLast}{$BID}{No};
          $TREE{$cladeName}{children}{$cladeChild} ++ ;
          $TREE{$cladeChild}{parent}{$cladeName} ++;
          # add child clade's annotation
          foreach my $b (sort keys %{$CLADE{$cladeLvLast}{$BID}{ANN}}){
            $CLADE{$cladeLv}{$BID}{ANN}{$b} = $ANNO{$b}{ident};
          }
        }else{
          $TREE{$cladeName}{members}{$BID} ++;
          # add unique annotation
          if($ANNO{$BID}{uniq} eq "unique"){
            $CLADE{$cladeLv}{$BID}{ANN}{$BID} = $ANNO{$BID}{ident};
          }
        }
      }elsif($s[0] eq "H"){
        my $BID8 = &getBID($s[8]);
        my $BID9 = &getBID($s[9]);

        if(exists $CLADE{$cladeLv}{$BID8}{No} ){
          die "$BID8 already presented. Check again.\n";
        }
        $CLADE{$cladeLv}{$BID8}{No} = $CLADE{$cladeLv}{$BID9}{No};
        my $cladeName = $cladeLv."__".$CLADE{$cladeLv}{$BID9}{No};
        # check whether this clade has a child clade
        if(exists $CLADE{$cladeLvLast}{$BID8}){
          my $cladeChild = $cladeLvLast."__".$CLADE{$cladeLvLast}{$BID8}{No};
          $TREE{$cladeName}{children}{$cladeChild} ++ ;
          $TREE{$cladeChild}{parent}{$cladeName} ++;
          # add child clade's annotation
          foreach my $b (sort keys %{$CLADE{$cladeLvLast}{$BID8}{ANN}}){
            $CLADE{$cladeLv}{$BID9}{ANN}{$b} = $ANNO{$b}{ident};
          }
        }else{
          $TREE{$cladeName}{members}{$BID8} ++;
          # add unique annotation
          if($ANNO{$BID8}{uniq} eq "unique"){
            $CLADE{$cladeLv}{$BID9}{ANN}{$BID8} = $ANNO{$BID8}{ident};
          }
        }
      }elsif($s[0] eq "C"){
        my $BID = &getBID($s[8]);
        my $cladeName = $cladeLv."__".$CLADE{$cladeLv}{$BID}{No};
        if($CLADE{$cladeLv}{$BID}{No} eq 1){
          my $debug = 1;
        }
        if(exists $TREE{$cladeName}{BID}){
          die "Duplicate cladeName ($cladeName by $BID vs. $TREE{$cladeName}{BID}) found! Check your data.\n";
        }
        if($cladeName eq "CLADE0.66__1"){
          my $debug =1 ;
        }
        #pick proper nodes from merged taxon tree
        my (%PICKS,$totalPick,$maxPick);
        my ($topTax,$topRank,$topRatio,$topChildTax,$topChildRank,$topChildRatio,@topChilds) = ("",0,0,"",2,0.5,());
        foreach my $bid (sort keys %{$CLADE{$cladeLv}{$BID}{ANN}}){
          my $taxid = $MAP{S}{$ANNO{$bid}{ID}};
          unless($taxid){
            $taxid = $DBTREE{quickIndex}{$ANNO{$bid}{tax}};
          }
          next if $ANNO{$bid}{ident} < $id * 100;
          $totalPick ++;
          my @trees = split /;/,$DBTREE{$taxid}{path};
          #my @nodes;
          my $unit = $ANNO{$bid}{U};

          for(my $i=0;$i<@trees;$i++){
            my $t = $trees[$i];
            (my $r = $t) =~ s/__.*$//;
            next unless $DEFAULT_IDENTITY{$r};
            $PICKS{$DEFAULT_IDENTITY{$r}}{$t} ++ ;
            if($PICKS{$DEFAULT_IDENTITY{$r}}{$t} > $maxPick){
              $maxPick = $PICKS{$DEFAULT_IDENTITY{$r}}{$t};
            }
          }
          #$PICKS{$nodes[-1]} ++ if @nodes > 0;
        }
        # pick top children rank
        foreach my $child (sort {$TREE{$a}{rankScore}<=>$TREE{$b}{rankScore}} keys %{$TREE{$cladeName}{children}}){
          if(exists $TREE{$child}{rankScore} && $TREE{$child}{rankScore} < $topChildRank && $TREE{$child}{rankRatio} > $topChildRatio){
            $topChildRank = $TREE{$child}{rankScore};
            $topChildTax  = $TREE{$child}{UNDERTAX};
            $topChildRatio= $TREE{$child}{rankRatio};
            push @topChilds, $child;
          }elsif(exists $TREE{$child}{rankScore} && $TREE{$child}{rankScore} eq $topChildRank){
            push @topChilds, $child;
          }
        }
        if(keys %PICKS > 0){
          unless(@topChilds){
            # pick top children's children rank
            foreach my $child2 (sort keys %{$TREE{$cladeName}{children}}){
              foreach my $child (sort {$TREE{$a}{rankScore}<=>$TREE{$b}{rankScore}} @{$TREE{$child2}{children2}}){
                if(exists $TREE{$child}{rankScore} && $TREE{$child}{rankScore} < $topChildRank && $TREE{$child}{rankRatio} > $topChildRatio){
                  $topChildRank = $TREE{$child}{rankScore};
                  $topChildTax  = $TREE{$child}{UNDERTAX};
                  $topChildRatio= $TREE{$child}{rankRatio};
                  push @topChilds, $child;
                }elsif(exists $TREE{$child}{rankScore} && $TREE{$child}{rankScore} eq $topChildRank){
                  push @topChilds, $child;
                }
              }
            }
          }
          foreach my $r (sort {$b <=> $a} keys %PICKS){
            if($r > $topChildRank){
              next;
            }else{
              foreach my $t (sort keys %{$PICKS{$r}}){
                # check thether the most picked taxon is dominant
                my $pickRatio = $PICKS{$r}{$t}/$totalPick;
                if($r eq $topChildRank){
                  if($pickRatio >= $topChildRatio * 0.98){
                    $topTax  = $t;
                    $topRank = $r;
                    $topRatio= $pickRatio;
                    # avoid duplicate ranks
                    for(@topChilds){
                      delete $TREE{$_}{rankScore};
                      delete $TREE{$_}{UNDERTAX};
                      delete $TREE{$_}{cladeLv};
                      delete $TREE{$_}{UNDERPATH};
                      $rankID ++;
                      $TREE{$_}{rankID} = $rankID;
                    }
                    last;
                  }
                }else{
                  if($PICKS{$r}{$t} >= $maxPick * 0.98){
                    $topTax  = $t;
                    $topRank = $r;
                    $topRatio= $pickRatio;
                    last;
                  }
                }
              }
              last if $topRatio;
            }
          }
          if($topRatio){
            $CLADE{$cladeLv}{$BID}{Node} = $topTax;
            $TREE{$cladeName}{BID} = $BID;
            $TREE{$cladeName}{UNDERTAX} = $topTax;
            $TREE{$cladeName}{UNDERPATH} = $DBTREE{$DBTREE{index}{$topTax}}{path};
            $TREE{$cladeName}{cladeLv} = $DBTREE{$DBTREE{index}{$topTax}}{rank};
            $TREE{$cladeName}{rankID} = $DBTREE{index}{$topTax};
            $TREE{$cladeName}{rankScore} = $topRank;
            $TREE{$cladeName}{rankRatio} = $topRatio;
          }else{
            $rankID ++;
            $TREE{$cladeName}{rankID} = $rankID;
          }
        }else{
          if($pmode eq "bac"){
            #for bac
            if($id == 0.97){
              $TREE{$cladeName}{cladeLv} = "genus";
            }elsif($id == 0.99){
              $TREE{$cladeName}{cladeLv} = "species";
            }
          }elsif($mode eq "euk"){
            #for euk
            if($id == 0.97){
              $TREE{$cladeName}{cladeLv} = "genus";
            }elsif($id == 0.99){
              $TREE{$cladeName}{cladeLv} = "species";
            }
          }
          $rankID ++;
          $TREE{$cladeName}{rankID} = $rankID;
        }
        $CLADE{$cladeLv}{NODES}{$cladeName} ++;
        $TREE{$cladeName}{presentID} = $BID;
        @{$TREE{$cladeName}{children2}} = @topChilds;
      }
    }
    $lastID = $id;
  }
  #assign all members

  &verbose("done\n  Writing ... ");

  foreach my $c (sort keys %{$CLADE{"CLADE$cladeInit"}{NODES}}){
    &printTree("",$c,\%TREE);
  }

  close FNA;
  close TID;
  close OUT;
  &verbose("done\n");
  return();
}

sub getBID{
  my $i = shift;
  my $id = ($i =~ /^(.*BI\d+)_k\d+_(\d+)_.*C([0-9]+|-)_/)?"$1\.$2\.$3":$i;
  return($id);
}

sub getIDs{
  my $i = shift;
  my $cid = ($i =~ /^(.*BI\d+)_k\d+_(\d+)_.*C([0-9]+|-)_/)?"$1\.$2\.$3":$i;
  my $bid = ($i =~ /^(.*BI\d+)_k\d+_(\d+)_.*C([0-9]+|-)_/)?"$1":$i;
  return($cid,$bid);
}

sub printTree{
  my($path,$clade,$T) = @_;
  if($clade eq "CLADE0.995__6842"){
    my $debug = 1;
  }
  $path .="$clade;";
  $rankID ++;
  $$T{$clade}{rankID} = $rankID;
  print OUT "$path\t$$T{$clade}{rankID}\t$$T{$clade}{cladeLv}\t$clade\t$$T{$clade}{UNDERTAX}\t$$T{$clade}{presentID}\n";
  foreach my $chs (sort keys %{$$T{$clade}{members}}){
    next unless $chs;
    next if exists $OCC{B}{$chs};
    $rankID ++;

    my $theRank = ($ANNO{$chs}{level})?$ANNO{$chs}{level}:"CLIP";
    #print OUT "$path$chs;\t$rankID\t$theRank\t$chs\t$ANNO{$chs}{tax}\t$ANNO{$chs}{A}\n";

    foreach my $s (sort keys %{$SEQ{$chs}}){
      print OUT "$path$s;\t$rankID\t$theRank\t$s\t$ANNO{$s}{tax}\t$ANNO{$s}{A}\n";
      print TID "$s\t$rankID\n";
      print FNA ">$s\n$SEQ{$chs}{$s}\n";
    }
    $OCC{B}{$chs} ++;
  }
  foreach my $c (sort keys %{$$T{$clade}{children}}){
    next unless exists $$T{$c}{children} or exists $$T{$c}{members};
    #my $pathc = ($$T{$c}{UNDERTAX})?"$$T{$c}{UNDERPATH}":"$path$c;";
    &printTree($path,$c,\%$T);
  }
}

##############################################################################
### tree2fa: get represent sequence of a specific rank level from a tree
##############################################################################
sub usage4tree2fa{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 tree2fa -i <fa> -r <rank> -d <clade> -t <db path> -o <output>
    -s  ssu fasta input file
    -l  lsu fasta input file
    -r  rank
    -d  clade if rank not available
    -t  db path tree
    -o  output file
    -p  check primer. Only SSU found FWD primer or LSU found REV primer retained.
    -a  Add annotation to seq id. May cause bug for phylotree generation.
    -v  verbose
    -h  show help info
USAGE
}
our(%ANNO,%MAP,%DBTREE,%RANKI,%SEQ,$rankID,%OCC);
$rankID = 1;
sub run_tree2fa{
  &usage4tree2fa("get represent sequence of a specific rank level from a tree") && exit unless @ARGV;
  my ($ssu,$lsu,$rank,$clade,$treefile,$withAnno,$checkPrimer,$out);
  GetOptions(
    "s=s" => \$ssu,
    "l=s" => \$lsu,
    "r=s" => \$rank,
    "d=s" => \$clade,
    "t=s" => \$treefile,
    "a"   => \$withAnno,
    "p"   => \$checkPrimer,
    "o=s" => \$out,
    "v"   => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4tree2fa("get represent sequence of a specific rank level from a tree") && exit if $help;
  my (%SEQ,%PICK,%TREE);
  open SSU, "< $ssu" or die $!;
  open LSU, "< $lsu" or die $!;
  open DBT, "< $treefile" or die $!;
  (my $outPfx = $out) =~ s/\.(fasta|fa|fna)$//;
  open OTBL, "> $outPfx.both.LSU.fa" or die $!;
  open OTBS, "> $outPfx.both.SSU.fa" or die $!;
  open OTS, "> $outPfx.SSU.fa" or die $!;
  open OTL, "> $outPfx.LSU.fa" or die $!;

  open IFB, "> $outPfx.both.inf" or die $!;
  open IFS, "> $outPfx.SSU.inf" or die $!;
  open IFL, "> $outPfx.LSU.inf" or die $!;

  &verbose("[tree2fa] start\n  Reading $ssu ... ");
  my $ori = $/;
  $/ = ">";
  while(<SSU>){
    chomp;
    next unless $_;
    my @s = split /\n/;
    my $id = shift @s;
    my ($cid,$bid) = &getIDs($id);
    my ($nf,$nr) = &getPmr($id);
    my $seq = join("",@s);
    my $len = length($seq);
    $SEQ{"SSU"}{$cid}{seq} = $seq;
    $SEQ{"SSU"}{$cid}{len} = $len;
    $SEQ{"SSU"}{$cid}{pmr} = $nf;
    $SEQ{"SSU"}{$cid}{score} = $len + ($checkPrimer && $nf)?10000:0;
    $SEQ{LINK}{$bid}{SSU}{$cid} ++;
  }
  close SSU;
  &verbose("done\n  Reading $lsu ... ");
  while(<LSU>){
    chomp;
    next unless $_;
    my @s = split /\n/;
    my $id = shift @s;
    my ($cid,$bid) = &getIDs($id);
    my ($nf,$nr) = &getPmr($id);
    my $seq = join("",@s);
    my $len = length($seq);
    $SEQ{"LSU"}{$cid}{seq} = $seq;
    $SEQ{"LSU"}{$cid}{len} = $len;
    $SEQ{"LSU"}{$cid}{pmr} = $nr;
    $SEQ{"LSU"}{$cid}{score} = $len + ($checkPrimer && $nr)?10000:0;
    $SEQ{LINK}{$bid}{LSU}{$cid} ++;

  }
  close LSU;
  $/ = $ori;
  &verbose("done\n  Reading $treefile ... ");
  while(<DBT>){
    #DBT format: path|taxID|rank|clade|taxName|represent bead|anno
    chomp;
    my @s = split /\t/;
    my ($repID,$bid) = &getIDs($s[5]);
    if($bid eq "S3BI00109150"){
      my $debug = 1;
    }
    $TREE{$s[3]} = ($s[4])?$s[4]:$s[3];
    my @path = split /;/,$s[0];
    my @alt = grep {keys %{$PICK{$_}} > 0} @path;
    if(@alt >1){
      my $debug =1 ;
    }
    die "Multiple picked clade found. Need check:".join(",",@alt)." at $.\n" if @alt > 1;
    if($s[2] eq $rank && $s[4]){
      my $findAlt = (@alt >0)?1:0;
      my $replace = ($findAlt && ($PICK{$alt[0]}{type} eq "clade" || $PICK{$alt[0]}{taxon} ne $s[4]) )?1:0;
      if($replace){
        delete $PICK{$alt[0]};
      }
      if($replace || $findAlt == 0){
        $PICK{$s[3]}{type} = "rank";
        $PICK{$s[3]}{rankID} = $s[1];
        $PICK{$s[3]}{taxon} = $s[4];
        $PICK{$s[3]}{path} = [@path];
        for my $u ("LSU","SSU"){
          if(exists $SEQ{$u}{$repID}{len}){
            if( $SEQ{$u}{$PICK{$s[3]}{$u}{ID}}{len} ){
              if($SEQ{$u}{$repID}{score} > $SEQ{$u}{$PICK{$s[3]}{$u}{ID}}{score}){
                $PICK{$s[3]}{$u}{ID} = $repID;
                $PICK{$s[3]}{path} = [@path]; # path of LSU will be overwriten by that of SSU if exists SSU path info
              }
            }else{
              $PICK{$s[3]}{$u}{ID} = $repID;
              $PICK{$s[3]}{path} = [@path];
            }
            $PICK{$s[3]}{BID}{$bid} ++;
          }
        }
      }
    }elsif( $s[2] =~ /$rank|$clade/){
      unless(@alt > 0 ){
        $PICK{$s[3]}{type} = "clade";
        $PICK{$s[3]}{rankID} = $s[1];
        $PICK{$s[3]}{taxon} = $s[3];
        $PICK{$s[3]}{path} = [@path];
        for my $u ("LSU","SSU"){
          if( exists $SEQ{$u}{$repID}{len} && (($checkPrimer && ($SEQ{$u}{$repID}{pmr} || $PICK{$s[3]}{type} eq "rank")) || not $checkPrimer) ){
            if( $SEQ{$u}{$PICK{$s[3]}{$u}{ID}}{len} ){
              if($SEQ{$u}{$repID}{score} > $SEQ{$u}{$PICK{$s[3]}{$u}{ID}}{score}){
                $PICK{$s[3]}{$u}{ID} = $repID;
                $PICK{$s[3]}{path} = [@path]; # LSU will be replaced by SSU if exists SSU path info
              }
            }else{
              $PICK{$s[3]}{$u}{ID} = $repID;
              $PICK{$s[3]}{path} = [@path];
            }
            $PICK{$s[3]}{BID}{$bid} ++;
          }
        }
      }
    }elsif(@alt > 0){
      for my $u ("LSU","SSU"){
        if(exists $SEQ{$u}{$repID}{len} && (($checkPrimer && ($SEQ{$u}{$repID}{pmr} || $PICK{$s[3]}{type} eq "rank")) || not $checkPrimer)){
          if($SEQ{$u}{$repID}{score} > $SEQ{$u}{$PICK{$alt[-1]}{$u}{ID}}{score}){
            $PICK{$alt[-1]}{$u}{ID} = $repID;
          }
          $PICK{$alt[-1]}{BID}{$bid} ++;
        }
      }
    }

  }
  close DBT;
  &verbose("done\n  Writing to $out ...");
  my (%TAX);
  my %COUNT = ("LSU",0,"SSU",0,"ALL",0,"MISS",0);
  foreach my $c (sort keys %PICK){

    my $taxon = $PICK{$c}{taxon};
    for my $u ("LSU","SSU"){
      if(exists $TAX{$taxon}{$u}{ID}){
        my $clade2rank = ($PICK{$c}{type} gt $TAX{$taxon}{type})?1:0;
        my $findLonger = ($PICK{$c}{type} eq $TAX{$taxon}{type} && $SEQ{$u}{$PICK{$c}{$u}{ID}}{score} > $SEQ{$u}{$TAX{$taxon}{$u}{ID}}{score})?1:0;
        if($clade2rank || $findLonger){
          $TAX{$taxon}{$u}{ID} = $PICK{$c}{$u}{ID};
          $TAX{$taxon}{path} = $PICK{$c}{path};
          $TAX{$taxon}{rankID} = $PICK{$c}{rankID};
          $TAX{$taxon}{type} = ($clade2rank)?$PICK{$c}{type}:$TAX{$taxon}{type};
        }
      }elsif(exists $PICK{$c}{$u}{ID}){
        $TAX{$taxon}{$u}{ID} = $PICK{$c}{$u}{ID};
        $TAX{$taxon}{path} = $PICK{$c}{path};
        $TAX{$taxon}{rankID} = $PICK{$c}{rankID};
        $TAX{$taxon}{type} = ($PICK{$c}{type} gt $TAX{$taxon}{type} )?$PICK{$c}{type}:$TAX{$taxon}{type};
      }else{
        #check if exist bead covered both SSU and LSU
        foreach my $b (sort keys %{$PICK{$c}{BID}}){
          foreach my $i (sort keys %{$SEQ{LINK}{$b}{$u}}){
            if(exists $SEQ{$u}{$TAX{$taxon}{$u}{ID}}{len}){
              if($SEQ{$u}{$i}{score} > $SEQ{$u}{$TAX{$taxon}{$u}{ID}}{score}){
                $TAX{$taxon}{$u}{ID} = $i;
              }
            }else{
              $TAX{$taxon}{$u}{ID} = $i;
              $TAX{$taxon}{$u}{type} = "sup";
            }
          }
        }
      }
      # keep clades for default phylum,genus and species
      # if($taxon=~/CLADE(0.72|0.97|0.99)/){
      #   $TAX{$taxon}{path} = $PICK{$c}{path};
      # }
    }
  }
  foreach my $c (sort keys %TAX){
    my ($tid,$cn,$cc,%FIND) = ($TAX{$c}{rankID},"","",());
    for my $u ("SSU","LSU"){
      if(exists $SEQ{$u}{$TAX{$c}{$u}{ID}}{len}){
        $FIND{$u} = 1;
        if ($TAX{$c}{$u}{type} eq "sup"){
          $FIND{"sup$u"} = 1;
        }elsif($TAX{$c}{type} eq "rank"){
          $FIND{"ann$u"} = 1;
        }elsif($TAX{$c}{type} eq "clade"){
          $FIND{"cld$u"} = 1;
        }
      }
    }
    my (@pn,@pc,$lastName,$lastClade);
    foreach my $p (@{$TAX{$c}{path}}){
      next if $TREE{$p} eq $lastName;
      push @pn, ($TREE{$p})?$TREE{$p}:$p;
      push @pc, $p;
      $lastName = $TREE{$p};
    }
    $cc = join(";",@pc);
    $cn = join(";",@pn);
    if($withAnno){
      #$cn =~ s/[)(:;,']//g;
      $cn =~ tr/ ()[]';/_<><>"\//;
    }

    if($FIND{SSU} == 1){
      print IFS "$tid\t$c\t$TAX{$c}{SSU}{ID}\t$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{len}\t$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{len}\t$cc\t$cn\n";
      if($withAnno){
        print OTS ">$cn\n$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq}\n";
      }else{
        print OTS ">$tid\n$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq}\n";
      }
      $COUNT{SSU} ++;
      $COUNT{supSSU} ++ if $FIND{supSSU} == 1;
      $COUNT{annSSU} ++ if $FIND{annSSU} == 1;
      $COUNT{cldSSU} ++ if $FIND{cldSSU} == 1;
    }
    if($FIND{LSU} == 1){
      print IFL "$tid\t$c\t$TAX{$c}{LSU}{ID}\t$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{len}\t$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{len}\t$cc\t$cn\n";
      if($withAnno){
        print OTL ">$cn\n$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq}\n";
      }else{
        print OTL ">$tid\n$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq}\n";
      }
      $COUNT{LSU} ++;
      $COUNT{supLSU} ++ if $FIND{supLSU} == 1;
      $COUNT{annLSU} ++ if $FIND{annLSU} == 1;
      $COUNT{cldLSU} ++ if $FIND{cldLSU} == 1;

    }
    if($FIND{SSU} + $FIND{LSU} == 2){
      my $str = join("\n",$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq},$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq});
      my $len = $SEQ{SSU}{$TAX{$c}{SSU}{ID}}{len} + $SEQ{LSU}{$TAX{$c}{LSU}{ID}}{len};
      print IFB "$tid\t$c\t$TAX{$c}{SSU}{ID}+$TAX{$c}{LSU}{ID}\t$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{len}\t$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{len}\t$cc\t$cn\n";
      if($withAnno){
        print OTBL ">$cn\n$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq}\n";
        print OTBS ">$cn\n$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq}\n";
      }else{
        print OTBL ">$tid\n$SEQ{LSU}{$TAX{$c}{LSU}{ID}}{seq}\n";
        print OTBS ">$tid\n$SEQ{SSU}{$TAX{$c}{SSU}{ID}}{seq}\n";
      }
      $COUNT{ALL} ++;
      $COUNT{valid} ++;
      $COUNT{supALL} ++ if $FIND{supSSU} + $FIND{supLSU} >= 1;
      if ($FIND{annSSU} + $FIND{annLSU} >= 1){
        $COUNT{annALL} ++;
      }else{
        $COUNT{cldALL} ++;
      }
    }elsif($FIND{SSU} + $FIND{LSU} == 1){
      $COUNT{valid} ++;
    }elsif($FIND{SSU} + $FIND{LSU} == 0){
      $COUNT{MISS} ++;
    }
  }

  close OUT;
  &verbose("done\n  Written $COUNT{valid} clade seqs. $COUNT{MISS} records cannot found seqs.\n");
  &verbose("  SSU: $COUNT{SSU} ($COUNT{annSSU}+$COUNT{cldSSU}+$COUNT{supSSU}) | LSU: $COUNT{LSU}($COUNT{annLSU}+$COUNT{cldLSU}+$COUNT{supLSU}) | BOTH:$COUNT{ALL}($COUNT{annALL}+$COUNT{cldALL}+$COUNT{supALL})\n");
  return();
}

sub getPmr{
  my $i = shift;
  my ($f,$r) = (0,0);
  my @parts = $i =~ /(REV|FWD)/g;
  foreach my $p (@parts){
    if($p eq "FWD"){
      $f ++;
    }elsif($p eq "REV"){
      $r ++;
    }
  }
  return($f,$r);
}

##############################################################################
### observedOTUs: stat observed OTUs when sampling reads raise
##############################################################################
sub usage4observedOTUs{
  my $msg = shift;
print <<USAGE;
$msg
usage:
  $0 observedOTUs -i <root dir> -o output.tsv sam1 sam2 sam3 ... samN
    -i  root dir where all samples' dir locate.
    -d  specific database name to stat
    -r  specific repeat to stat
    -o  output filename
    ..  sample directory tags. read by provide order.
    -v  verbose
    -h  show help info
USAGE
}
sub run_observedOTUs{
  &usage4observedOTUs("stat observed OTUs when sampling reads raise") && exit unless @ARGV;
  my ($idir,$setdb,$setsize,$setrep,$db,$out);
  GetOptions(
    "i=s" => \$idir,
    "d=s" => \$setdb,
    "r=i" => \$setrep,
    "s=i" => \$setsize,
    "o=s" => \$out,
    "v" => \$verbose,
    "h|help|?" => \$help,
  );
  &usage4observedOTUs("stat observed OTUs when sampling reads raise") && exit if $help;
  #&usage("[fatal] Essential input is missing");
  &verbose("[log] Mode [observedOTUs] start ... \n  SAM: DB[REP][size] status:\n");
  open OUT,">$out" or die $!;
  my(%SAMIMAGE,%STAT);
  $setdb  ||= '*';
  $setsize||= '*';
  $setrep = '*' if $setrep eq "";
  while(@ARGV){
    my $sam = shift @ARGV;
    my @files = `ls $idir/$sam/KRAKEN/rand/$setdb\_$setsize.$setrep.bead.kreport2`;
    my %INFO = ();
    for(@files){
      $_ =~ /rand\/(\S+)_(\d+)\.(\d+)\.bead\.kreport2$/;
      $INFO{$1}{$3}{$2}{SAM} = $sam;
      $INFO{$1}{$3}{$2}{FILE} = $_;
    }
    my ($dbCount,$repCount,$maxSize) = (0,0,0);
    foreach my $db (sort keys %INFO){
      $dbCount ++;
      foreach my $rep (sort {$a<=>$b} keys %{$INFO{$db}}){
        $repCount ++;
        $SAMIMAGE{$db}{$rep}{T}{"psudoTaxForInit"} = 0;
        my @sizes = sort {$a<=>$b} keys %{$INFO{$db}{$rep}};
        foreach my $size (@sizes){
          &verbose("  $sam: $db\[$rep\]\[$size\] ...         \r");
          my %BASE = %{$SAMIMAGE{$db}{$rep}{T}};
          my ($count,$rBead,$tBead,$unclassified) = (0,0,0,0);
          open KK," < $INFO{$db}{$rep}{$size}{FILE}" or die $!;
          while(<KK>){
            my @s=split;
            if($s[3] eq "S"){
              $BASE{$s[4]} += $s[1];
              $rBead += $s[1];
            }elsif($s[3] eq "U"){
              $unclassified = $s[1];
            }
            $tBead += $s[2];
          }
          close KK;
          $count = grep {$BASE{$_} >= 10} %BASE;
          my $taxSize = keys %BASE;
          # stat
          my $cSize = $SAMIMAGE{$db}{$rep}{S} + $size;
          $STAT{$db}{$rep}{$cSize}{samSize} = $size;
          $STAT{$db}{$rep}{$cSize}{samName} = $sam;
          $STAT{$db}{$rep}{$cSize}{countOTUs} = $count;
          $STAT{$db}{$rep}{$cSize}{rankBeads} = $rBead + $SAMIMAGE{$db}{$rep}{R};
          $STAT{$db}{$rep}{$cSize}{totalBeads} = $tBead + $SAMIMAGE{$db}{$rep}{B};
          $STAT{$db}{$rep}{$cSize}{unclassified} = $unclassified + $SAMIMAGE{$db}{$rep}{U};
          $STAT{$db}{$rep}{$cSize}{taxsize} = $taxSize;
          # next size or save image of tax from the last size
          if($size == $sizes[-1]){
            $SAMIMAGE{$db}{$rep}{B} += $tBead;
            $SAMIMAGE{$db}{$rep}{R} += $rBead;
            $SAMIMAGE{$db}{$rep}{U} += $unclassified;
            $SAMIMAGE{$db}{$rep}{S}  = $cSize;
            %{$SAMIMAGE{$db}{$rep}{T}}  = %BASE;
            $maxSize = ($size > $maxSize)?$size:$maxSize;
          }
        }
        # next repeat
      }
      # next database
    }
    &verbose("  $sam: $dbCount dbs\[$repCount\]\[$maxSize\] pass\n");
    # next sample
  }
  &verbose("[log] pass reading! Now Writing ... ");
  foreach my $db (sort keys %STAT){
    foreach my $rep (sort {$a<=>$b} keys %{$STAT{$db}}){
      foreach my $cSize (sort {$a<=>$b} keys %{$STAT{$db}{$rep}}){
        print OUT join("\t",$db,$rep,$STAT{$db}{$rep}{$cSize}{samName},$STAT{$db}{$rep}{$cSize}{samSize},
        $cSize,$STAT{$db}{$rep}{$cSize}{countOTUs},$STAT{$db}{$rep}{$cSize}{totalBeads},
        $STAT{$db}{$rep}{$cSize}{rankBeads},$STAT{$db}{$rep}{$cSize}{unclassified},$STAT{$db}{$rep}{$cSize}{taxsize})."\n";
      }
    }
  }
  close OUT;
  &verbose("done!\n");
  return();
}



















#FIN
